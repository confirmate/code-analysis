/*
 * This file is part of the Confirmate project.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.assumptions.AssumptionType
import de.fraunhofer.aisec.cpg.assumptions.assume
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpEndpoint
import de.fraunhofer.aisec.cpg.graph.concepts.manualExtensions.ExtendedHttpEndpoint
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended

context(translationResult: TranslationResult)
fun endpointsHaveRateLimiting(): QueryTree<Boolean> {
    return translationResult.allExtended<HttpEndpoint> {
        val result =
            QueryTree(
                value = it is ExtendedHttpEndpoint && it.rateLimiting != null,
                stringRepresentation =
                    if (it is ExtendedHttpEndpoint && it.rateLimiting != null) {
                        "Endpoint ${it.name} has rate limiting configured: ${it.rateLimiting}"
                    } else {
                        "Endpoint ${it.name} does not have rate limiting configured"
                    },
                node = it,
                operator = GenericQueryOperators.EVALUATE,
            )
        if (result.value) {
            result.assume(
                AssumptionType.ExternalDataAssumption,
                "We assume that the rate limiting on endpoint ${it.name} has meaningful limits: ${(it as? ExtendedHttpEndpoint)?.rateLimiting?.maxRequests} per  ${(it as? ExtendedHttpEndpoint)?.rateLimiting?.timeWindowSeconds} seconds.\n\nTo validate this assumption, we should identify if this makes sense for the performance of our system and the expected load.",
            )
        } else {
            result
        }
    }
}

context(translationResult: TranslationResult)
fun endpointsHaveSizeLimiting(): QueryTree<Boolean> {
    return translationResult.allExtended<HttpEndpoint> {
        val result =
            QueryTree(
                value =
                    it is ExtendedHttpEndpoint &&
                        (it.userInput.isEmpty() || it.maxInputSize != null),
                stringRepresentation =
                    if (it is ExtendedHttpEndpoint && it.userInput.isEmpty()) {
                        "Endpoint ${it.name} does not receive any inputs from users."
                    } else if (it is ExtendedHttpEndpoint && it.maxInputSize != null) {
                        "Endpoint ${it.name} has a limited size for user inputs configured: ${it.maxInputSize}"
                    } else {
                        "Endpoint ${it.name} does not limit the size of user inputs. This could lead to resource exhaustion attacks."
                    },
                node = it,
                operator = GenericQueryOperators.EVALUATE,
            )
        if (it is ExtendedHttpEndpoint && it.maxInputSize != null) {
            result.assume(
                AssumptionType.ExternalDataAssumption,
                "We assume that the size of the user inputs for endpoint ${it.name} has meaningful limits: ${it.maxInputSize}.\n\nTo validate this assumption, we should identify if this makes sense for the performance of our system and the expected load.",
            )
        } else {
            result
        }
    }
}
