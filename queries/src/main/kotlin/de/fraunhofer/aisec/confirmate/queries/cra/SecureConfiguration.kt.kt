/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.queries.catalogs.SecureConfigurationsCatalog
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.graph.Backward
import de.fraunhofer.aisec.cpg.graph.Forward
import de.fraunhofer.aisec.cpg.graph.GraphToFollow
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.OverlayNode
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AccessRestriction
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AtRestEncryption
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Attestation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AuthenticationOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Authorization
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AutomaticUpdates
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Certificate
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CheckAccess
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CipherOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CodeRepository
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Configuration
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.ConfigurationOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.ConfigurationOption
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.ContainerOrchestration
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.ContainerRegistry
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CreateEncryptedDisk
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CreateSecret
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CryptographicHash
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CustomerKeyEncryption
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DDoSProtection
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseConnect
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseService
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseStorage
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DynamicLoadingOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Encryption
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.EncryptionOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Firewall
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpServer
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.LoggingService
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.MalwareProtection
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.MultiFactorAuthentiation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.NetworkService
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Networking
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.PolicyOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.ProtectedAssetOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.RegisterHttpEndpoint
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.SecretOperation
import de.fraunhofer.aisec.cpg.graph.statements.expressions.Literal
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.May
import de.fraunhofer.aisec.cpg.query.NotYetEvaluated.node
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.dataFlow
import javax.crypto.SecretKeyFactory

// Ideas:
// - Check for usage of secure protocols (e.g., HTTPS, TLS)
// - Check for strong encryption algorithms and key lengths
// - Check for secure authentication mechanisms
// OR:
// - Check for absence of known insecure configurations
// - Check for concepts that represent secure configurations
// - Check if a configuration can be secure and is not
// - Check for Functionality that is security relevant and whether they get configuration input
// - Check if the configuration is on a secure value
// - Check if the configured value goes to a validation that we can define as secure

fun securityConfigurationSinkSelector(node: Node): Boolean {
    val securityConceptsInCode =
        listOf(
            SecretOperation::class.java,
            SecretKeyFactory::class.java,
            Encryption::class.java,
            EncryptionOperation::class.java,
            CustomerKeyEncryption::class.java,
            CustomerKeyEncryption::class.java,
            AtRestEncryption::class.java,
            Attestation::class.java,
            AuthenticationOperation::class.java,
            Authorization::class.java,
            AutomaticUpdates::class.java,
            Certificate::class.java,
            AccessRestriction::class.java,
            CheckAccess::class.java,
            CipherOperation::class.java,
            CodeRepository::class.java,
            ContainerRegistry::class.java,
            ContainerOrchestration::class.java,
            CreateEncryptedDisk::class.java,
            CreateSecret::class,
            CryptographicHash::class.java,
            DDoSProtection::class.java,
            DynamicLoadingOperation::class.java,
            HttpServer::class.java,
            LoggingService::class
                .java, // instantiating a logging service can be configured with security relevant
            // configs,
            MalwareProtection::class.java,
            MultiFactorAuthentiation::class.java,
            Networking::class.java,
            NetworkService::class.java,
            PolicyOperation::class.java,
            ProtectedAssetOperation::class.java,
            RegisterHttpEndpoint::class.java,
            DatabaseConnect::class.java,
            DatabaseService::class.java,
            DatabaseStorage::class.java,
            Firewall::class.java,
        )
    return securityConceptsInCode.any { it == node.javaClass }
}

fun securityConfigurationSelector(node: Node): Boolean {
    val securityKeywords =
        listOf("secure", "ssl", "tls", "encrypt", "auth", "password", "token", "key")
    return securityKeywords.any { node.name.toString()?.lowercase()?.contains(it) == true }
}

context(translationResult: TranslationResult)
fun secureConfigAlwaysUsed(
    isSecurityConfiguration: (Node) -> Boolean = ::securityConfigurationSelector,
    isSecurityConfigurationSink: (Node) -> Boolean = ::securityConfigurationSinkSelector,
): QueryTree<Boolean> {
    // This query reads: If a configuration is security relevant, using the isSecurityConfiguration
    // selector, we need to
    // ensure that it is used somewhere in the program to set a secure configuration to an
    // operation. The analysis is a
    // May analysis, because the configuration data does not have to flow into such an operation in
    // all cases, but logging
    // of security parameters is legitimate as well.
    return translationResult.allExtended<OverlayNode>(
        sel = { it ->
            (it is Configuration || it is ConfigurationOperation || it is ConfigurationOption) &&
                isSecurityConfiguration(it)
        }
    ) { node ->
        dataFlow(
            startNode = node,
            direction = Forward(GraphToFollow.DFG),
            type = May,
            predicate = { node -> isSecurityConfigurationSink(node) },
        )
    }
}

/**
 * Query to ensure that data going into security relevant operations is not coming from constants in
 * the code, but configuration files or external data.
 */
context(translationResult: TranslationResult)
fun noNonConfigConstantsToSecureOperation(
    isSecurityConfiguration: (Node) -> Boolean = ::securityConfigurationSelector,
    isSecurityConfigurationSink: (Node) -> Boolean = ::securityConfigurationSinkSelector,
): QueryTree<Boolean> {
    return translationResult.allExtended<Node>(
        sel = { it -> securityConfigurationSinkSelector(it) }
    ) { node ->
        dataFlow(
            startNode = node,
            direction = Backward(GraphToFollow.DFG),
            earlyTermination = { node -> node is Literal<*> },
            predicate = { node ->
                (node is Configuration ||
                    node is ConfigurationOperation ||
                    node is ConfigurationOption) || node.prevDFGEdges.isEmpty()
            },
        )
    }
}

context(translationResult: TranslationResult, secureConfiguration: SecureConfigurationsCatalog)
fun secureValuesConfigured(): QueryTree<Boolean> {
    return translationResult.allExtended<ConfigurationOption> { confOp ->
        QueryTree<Boolean>(
            value =
                secureConfiguration.isSecureConfigValue(
                    confOp.name.toString(),
                    confOp.value.toString(),
                ),
            stringRepresentation =
                "The configuration of the value ${confOp.name} is either not security relevant or its value ${confOp.value} is considered to be secure by the default configuration.",
            node = null,
            operator = GenericQueryOperators.EVALUATE,
        )
    }
}
