/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.queries.LogWriteWithArguments
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.graph.Backward
import de.fraunhofer.aisec.cpg.graph.Forward
import de.fraunhofer.aisec.cpg.graph.GraphToFollow
import de.fraunhofer.aisec.cpg.graph.Interprocedural
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.allChildrenWithOverlays
import de.fraunhofer.aisec.cpg.graph.concepts.Concept
import de.fraunhofer.aisec.cpg.graph.concepts.Operation
import de.fraunhofer.aisec.cpg.graph.concepts.auth.AuthenticationOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AnomalyDetection
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Identity
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.MultiFactorAuthentiation
import de.fraunhofer.aisec.cpg.graph.concepts.http.HttpEndpoint
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.Must
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.dataFlow
import de.fraunhofer.aisec.cpg.query.executionPath
import de.fraunhofer.aisec.cpg.query.existsExtended
import de.fraunhofer.aisec.cpg.query.mergeWithAll

val endpoints = listOf(HttpEndpoint::class)

fun criticalSelector(node: Node): Boolean {

    return node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseOperation ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.FileOperation ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpClientOperation ||
            node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.ConfigurationOperation ||
    node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.BlockStorageOperation ||
    node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CreateEncryptedDisk ||
    node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DDoSProtection  ||
            node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CryptographicOperation ||
            node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DiskEncryptionOperation ||
            node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DynamicLoadingOperation ||
            node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.SecretOperation ||
            node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpEndpointOperation ||
            node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.MemoryOperation


}

fun authenticationSelector(node: Node): Boolean {
    val authKeywords = listOf("auth", "login", "signin", "sign-in", "sign_in")
    return authKeywords.any { node.name.toString()?.lowercase()?.contains(it) == true } ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AuthenticationOperation ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.TokenBasedAuthentication ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.PasswordBasedAuthentication ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.OTPBasedAuthentication
}

fun authorizationSelector(node: Node): Boolean {
    val authorizationKeywords =
        listOf("access", "permit", "privilege", "role", "authz", "authoriz", "token")
    return authorizationKeywords.any { node.name.toString()?.lowercase()?.contains(it) == true } ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AccessRestriction ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Authorization ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AuthorizeJwt ||
        node is de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.CheckAccess
}

context(translationResult: TranslationResult)
fun authenticationAtEndpoint(isAuthentication: (Node) -> Boolean) =
    getEndpoints()
        .map { endpoint ->
            executionPath(
                startNode = endpoint,
                direction = Forward(GraphToFollow.EOG),
                type = Must,
                scope = Interprocedural(),
            ) {
                isAuthentication(it)
            }
        }
        .mergeWithAll()

context(translationResult: TranslationResult)
fun authorizationAtEndpoint(isAuthorization: (Node) -> Boolean) =
    getEndpoints()
        .map { endpoint ->
            executionPath(
                startNode = endpoint,
                direction = Forward(GraphToFollow.EOG),
                type = Must,
                scope = Interprocedural(),
            ) {
                isAuthorization(it)
            }
        }
        .mergeWithAll()

context(translationResult: TranslationResult)
fun authenticationBeforeCriticalFunctionality(
    isAuthentication: (Node) -> Boolean,
    isCritical: (Node) -> Boolean,
) =
    getCriticalFunctionality(isCritical)
        .map { endpoint ->
            executionPath(
                startNode = endpoint,
                direction = Forward(GraphToFollow.EOG),
                type = Must,
                scope = Interprocedural(),
            ) {
                isAuthentication(it)
            }
        }
        .mergeWithAll()

context(translationResult: TranslationResult)
fun authorizationBeforeCriticalFunctionality(
    isAuthorization: (Node) -> Boolean,
    isCritical: (Node) -> Boolean,
): QueryTree<Boolean> =
    getCriticalFunctionality(isCritical)
        .map { endpoint ->
            executionPath(
                startNode = endpoint,
                direction = Forward(GraphToFollow.EOG),
                type = Must,
                scope = Interprocedural(),
            ) {
                isAuthorization(it)
            }
        }
        .mergeWithAll()

/**
 * Currently this check evaluates to true if there is any logging reachable from the negative branch
 * of a node, considered to be evaluation. This could be refined, although we expect to not have
 * merging baths of a successful and unsuccessful authentication/authorization.
 */
context(translationResult: TranslationResult)
fun loggingOnSecurityErrors(
    isAuthentication: (Node) -> Boolean,
    isAuthorization: (Node) -> Boolean,
): QueryTree<Boolean> {
    val errorNodes =
        getSecurityErrors(getAuthentication(isAuthentication))
            .union(getSecurityErrors(getAuthorization(isAuthorization)))

    return errorNodes
        .map { errorNode ->
            executionPath(
                startNode = errorNode,
                direction = Forward(GraphToFollow.EOG),
                type = Must,
                scope = Interprocedural(),
            ) { node ->
                node is LogWriteWithArguments && node.isLevelEnabled
            }
        }
        .mergeWithAll()
}

context(translationResult: TranslationResult)
fun adminAuthenticationWithMFA(isAuthentication: (Node)-> Boolean, isAdminEndpoint: (Node) -> Boolean = {n -> n.name.toString().lowercase().contains("admin")}) : QueryTree<Boolean> {
    return translationResult.allExtended<Node>({ n -> isAdminEndpoint(n)  }, {
        executionPath(
            startNode = it,
            direction = Forward(GraphToFollow.DFG),
            type = Must,
            earlyTermination = { n -> n is AuthenticationOperation  && n.concept !is MultiFactorAuthentiation},
            scope = Interprocedural(),
            predicate = { n -> n is AuthenticationOperation && n.concept is MultiFactorAuthentiation }
        )
    })
}

context(translationResult: TranslationResult)
fun identityPasswordPolicyEnabled(): QueryTree<Boolean> {
    return translationResult.allExtended<Identity> { node -> QueryTree<Boolean>(
        value = node.disablePasswordPolicy == false,
        stringRepresentation = "Identity ${node.name} has password policy enabled",
        node = node,
        operator = GenericQueryOperators.EVALUATE,
    )  }
}

context(translationResult: TranslationResult)
fun anomalyDetectionEnabled(): QueryTree<Boolean> {
    return translationResult.allExtended<AnomalyDetection> { node -> QueryTree<Boolean>(
        value = node.enabled ,
        stringRepresentation = "Anomaly detection ${node.name} is enabled",
        node = node,
        operator = GenericQueryOperators.EVALUATE,
    )  }
}


context(translationResult: TranslationResult)
fun getAuthentication(isAuthentication: (Node) -> Boolean) =
    translationResult.allChildrenWithOverlays<Node>(isAuthentication)

context(translationResult: TranslationResult)
fun getAuthorization(isAuthorization: (Node) -> Boolean) =
    translationResult.allChildrenWithOverlays<Node>(isAuthorization)

/**
 * This function return the first node after a branch that leads to a path that will be executed
 * after an evaluation to `false`. This can be used to build a further paths for inspection.
 */
context(translationResult: TranslationResult)
fun getSecurityErrors(securityChecks: List<Node>) =
    securityChecks.flatMap { it.nextEOGEdges.filter { !(it.branch ?: true) }.map { it.end } }

context(translationResult: TranslationResult)
fun getEndpoints(): List<Node> {
    return translationResult.allChildrenWithOverlays<Node>({ node ->
        endpoints.any { it -> it.isInstance(node) }
    })
}

context(translationResult: TranslationResult)
fun getCriticalFunctionality(isCritical: (Node) -> Boolean): List<Node> {
    return translationResult.allChildrenWithOverlays<Node>(isCritical)
}
