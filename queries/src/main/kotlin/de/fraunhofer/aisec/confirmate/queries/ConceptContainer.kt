/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries

import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.concepts.Concept
import de.fraunhofer.aisec.cpg.graph.concepts.Operation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.*
import de.fraunhofer.aisec.cpg.graph.concepts.http.HttpMethod
import java.time.Duration

/*
This file contains a collection of Concepts and Operations which provide additional information compared to the basic CPG model.
They can be used to build more complex queries and encode more information which is required for evaluating the CRA and the
SOTA of certain regulations/standards/requirements/guidelines. The classes should be migrated to the CPG project if they are generally useful or to the ontology.
 */

/**
 * This class represents a symmetric cipher used for encryption and decryption of data. It extends
 * the [Cipher] class and includes additional properties specific to symmetric ciphers, such as the
 * mode of operation, tag size, IV size, and the initialization vector itself.
 */
class SymmetricCipher(
    blockSize: Int,
    keySize: Int,
    cipherName: String?,
    padding: Padding?,
    underlyingNode: Node?,
) :
    Cipher(
        blockSize,
        keySize = keySize,
        cipherName = cipherName,
        padding = padding,
        underlyingNode = underlyingNode,
    ) {
    /** The modus of operation, e.g., "GCM", "CBC", "CCM", ... */
    var modus: String? = null
    /** The size of an authentication tag in bits, if present for the given [modus]. */
    var tagSize: Int? = null
    /** The size of the initialization vector (IV) in bits, if present for the given [modus]. */
    var ivSize: Int? = null
    /**
     * The initialization vector (IV) itself, if present for the given [modus]. TODO: Maybe move
     * this to the encrypt operation??
     */
    var iv: Node? = null
}

/**
 * This class represents a hybrid encryption and decryption scheme. These consist of a symmetric
 * encryption scheme, a key exchange.
 */
class HybridCipher(
    blockSize: Int,
    keySize: Int,
    cipherName: String,
    padding: Padding?,
    underlyingNode: Node?,
) :
    Cipher(
        blockSize = blockSize,
        keySize = keySize,
        cipherName = cipherName,
        padding = padding,
        underlyingNode = underlyingNode,
    ) {
    var symmetricCipher: SymmetricCipher? = null

    var keyExchange: Cipher? = null // TODO: Maybe we do not need this here.

    var hashFunction: HashFunction? = null
}

open class HashFunction(
    var hashFunctionName: String? = null,
    var outputSize: Int? = null,
    underlyingNode: Node?,
) : Concept(underlyingNode)

open class TLS(
    versionNumber: Float,
    cipherSuites: MutableList<CipherSuite?>,
    basedOn: Cipher,
    secret: Secret,
    underlyingNode: Node,
) :
    TransportEncryption(
        true,
        true,
        "TLS",
        versionNumber,
        cipherSuites,
        basedOn,
        secret,
        underlyingNode,
    )

class TLS1_2(
    val cipherSuites12: MutableList<TLS1_2_CipherSuite>,
    basedOn: Cipher,
    secret: Secret,
    underlyingNode: Node,
) : TLS(1.2f, cipherSuites12.toMutableList(), basedOn, secret, underlyingNode)

class TLS1_3(
    /** The supported groups (also known as elliptic curves) communicated by this client/server. */
    val supportedGroups: Set<String>,
    /** The supported signature algorithms communicated by this client/server. */
    val signatureAlgorithms: Set<String>,
    /** The supported PSK modes communicated by this client/server. */
    val pskHandshakeModes: Set<String>,
    /**
     * The supported fields sent in signature_algorithms_cert" in the "certificate_authority"
     * extension of a certificate request sent from the server to the client or what is
     * used/supported by the client. `null` if no certificate request was sent.
     */
    val certificateSignatureAlgorithms: Set<String>? = null,
    /** The supported AEAD algorithms communicated by this client/server. */
    basedOn: Cipher,
    secret: Secret,
    cipherSuites: MutableList<CipherSuite?>,
    underlyingNode: Node,
) : TLS(1.3f, cipherSuites, basedOn, secret, underlyingNode)

class TLS1_2_CipherSuite(
    val ciphersuiteName: String?,
    authenticationMechanism: String?,
    keyExchangeAlgorithm: String?,
    macAlgorithm: String?,
    ciphers: MutableList<Cipher?>,
    val supportedGroups: List<String?>,
    underlyingNode: Node?,
) :
    CipherSuite(
        authenticationMechanism,
        keyExchangeAlgorithm,
        macAlgorithm,
        ciphers,
        underlyingNode!!,
    )

/**
 * This class represents a Random Number Generator (RNG) concept in the code property graph (CPG).
 * It extends the [Concept] class and is used to identify nodes in the CPG that are associated with
 * random number generation functionality.
 */
class RNG(underlyingNode: Node?) : Concept(underlyingNode)

/**
 * This class represents an operation that retrieves random numbers from a random number generator
 * (RNG). It extends the [Operation] class and is associated with an [RNG] concept to indicate that
 * it performs a get operation on the RNG.
 */
class RngGet(underlyingNode: Node?, val rng: RNG) : Operation(rng, underlyingNode)

/** The [underlyingNode] gets the current time of the system. */
class GetCurrentTime(concept: Concept, underlyingNode: Node?) :
    Operation(concept = concept, underlyingNode = underlyingNode)

class LoggingWithLevel(
    val logLevelThreshold: LogLevel?,
    enabled: Boolean?,
    monitoringEnabled: Boolean?,
    name: String?,
    retentionPeriod: Duration?,
    securityAlertsEnabled: Boolean?,
    loggingService: LoggingService?,
    underlyingNode: Node?,
) :
    Logging(
        enabled,
        monitoringEnabled,
        name,
        retentionPeriod,
        securityAlertsEnabled,
        loggingService,
        underlyingNode,
    )

class InputValidation(
    val input: Node?,
    val validatedOutput: Node?,
    concept: Concept,
    underlyingNode: Node?,
) : Operation(concept, underlyingNode)

class LogWriteWithArguments(
    val logArguments: List<Node?>,
    logLevel: LogLevel?,
    override val concept: LoggingWithLevel,
    underlyingNode: Node?,
) : LogWrite(logLevel, concept, underlyingNode)

class HttpClientWithProtocol(
    var protocol: TransportEncryption?,
    authenticity: Authenticity?,
    underlyingNode: Node?,
) :
    HttpClient(
        isTLS = protocol is TLS,
        authenticity = authenticity,
        underlyingNode = underlyingNode,
    )

class HttpRequestWithArguments(
    val arguments: List<Node>,
    val httpMethod: HttpMethod?,
    val url: String?,
    call: String?,
    reqBody: String?,
    httpEndpoint: HttpEndpoint?,
    linkedConcept: HttpClientWithProtocol,
    underlyingNode: Node?,
) :
    HttpRequest(
        call = call,
        reqBody = reqBody,
        httpEndpoint = httpEndpoint,
        linkedConcept = linkedConcept,
        underlyingNode = underlyingNode,
    )

class DatabaseQueryWithInput(
    val parameters: List<Node>,
    modify: Boolean?,
    calls: java.util.List<String>?,
    databaseService: DatabaseService?,
    storage: DatabaseStorage?,
    linkedConcept: DatabaseStorage,
    underlyingNode: Node?,
) :
    DatabaseQuery(
        modify = modify,
        calls = calls,
        databaseService = databaseService,
        storage = storage,
        linkedConcept = linkedConcept,
        underlyingNode = underlyingNode,
    )

class RateLimiting(val maxRequests: Int, val timeWindowSeconds: Int, underlyingNode: Node?) :
    Concept(underlyingNode)

class ExtendedHttpEndpoint(
    val rateLimiting: RateLimiting?,
    val maxInputSize: Int?,
    val userInput: MutableList<Node>,
    handler: String?,
    method: String?,
    path: String?,
    url: String?,
    authenticity: Authenticity?,
    authorization: Authorization?,
    httpRequestContext: HttpRequestContext?,
    proxyTarget: HttpEndpoint?,
    transportEncryption: TransportEncryption?,
    underlyingNode: Node?,
) :
    HttpEndpoint(
        handler,
        method,
        path,
        url,
        authenticity,
        authorization,
        httpRequestContext,
        proxyTarget,
        transportEncryption,
        underlyingNode,
    )

class SHA_256(underlyingNode: Node?) :
    HashFunction(hashFunctionName = "SHA-256", outputSize = 256, underlyingNode = underlyingNode)

class SHA_384(underlyingNode: Node?) :
    HashFunction(hashFunctionName = "SHA-284", outputSize = 384, underlyingNode = underlyingNode)

class SHA_512(underlyingNode: Node?) :
    HashFunction(hashFunctionName = "SHA-512", outputSize = 512, underlyingNode = underlyingNode)

class SHA_512_256(underlyingNode: Node?) :
    HashFunction(
        hashFunctionName = "SHA-512/256",
        outputSize = 256,
        underlyingNode = underlyingNode,
    )

class SHA3_256(underlyingNode: Node?) :
    HashFunction(hashFunctionName = "SHA3-256", outputSize = 256, underlyingNode = underlyingNode)

class SHA3_384(underlyingNode: Node?) :
    HashFunction(hashFunctionName = "SHA3-384", outputSize = 384, underlyingNode = underlyingNode)

class SHA3_512(underlyingNode: Node?) :
    HashFunction(hashFunctionName = "SHA3-512", outputSize = 512, underlyingNode = underlyingNode)

class DHKeyExchange(pSize: Int?, underlyingNode: Node?) :
    AsymmetricCipher(
        blockSize = pSize,
        cipherName = "DH",
        keySize = pSize,
        padding = null,
        underlyingNode = underlyingNode,
    )

class ECDHKeyExchange(val parameter: String?, pSize: Int?, underlyingNode: Node?) :
    AsymmetricCipher(
        blockSize = pSize,
        cipherName = "ECDH",
        keySize = pSize,
        padding = null,
        underlyingNode = underlyingNode,
    )

class CMAC(val cipher: Cipher?, input: Input?, key: Key?, underlyingNode: Node?) :
    MessageAuthenticationCode(
        type = "CMAC",
        input = input,
        key = key,
        underlyingNode = underlyingNode,
    )

class GMAC(
    val cipher: Cipher?,
    val iv: InitializationVector?,
    input: Input?,
    key: Key?,
    underlyingNode: Node?,
) :
    MessageAuthenticationCode(
        type = "GMAC",
        input = input,
        key = key,
        underlyingNode = underlyingNode,
    )

class KMAC(
    val hashFunction: HashFunction?,
    val strength: Int?,
    input: Input?,
    key: Key?,
    underlyingNode: Node?,
) :
    MessageAuthenticationCode(
        type = "KMAC",
        input = input,
        key = key,
        underlyingNode = underlyingNode,
    )

class HMAC(val hashFunction: HashFunction?, input: Input?, key: Key?, underlyingNode: Node?) :
    MessageAuthenticationCode(
        type = "HMAC",
        input = input,
        key = key,
        underlyingNode = underlyingNode,
    )

open class Signature(val schemeName: String?, val key: Key?, underlyingNode: Node?) :
    Concept(underlyingNode = underlyingNode)

class RSASignature(
    val rsaCipher: AsymmetricCipher?,
    val formattingScheme: FormattingScheme?,
    key: Key?,
    underlyingNode: Node?,
) : Signature(schemeName = "RSA", key = key, underlyingNode = underlyingNode)

class DSASignature(
    val primePSize: Int?,
    val primeQSize: Int?,
    val hashFunction: HashFunction?,
    key: Key?,
    underlyingNode: Node?,
) : Signature(schemeName = "DSA", key = key, underlyingNode = underlyingNode)

class ECDSASignature(
    val parameter: String?,
    val algorithmName: String?,
    val hashFunction: HashFunction?,
    key: Key?,
    underlyingNode: Node?,
) : Signature(schemeName = "DSA", key = key, underlyingNode = underlyingNode)

class SlhDsaSignature(
    val parameter: String?,
    val algorithmName: String?,
    val variant: Variant?,
    val hashFunction: HashFunction?,
    val version: Version?,
    key: Key?,
    underlyingNode: Node?,
) : Signature(schemeName = "SLH-DSA", key = key, underlyingNode = underlyingNode)

class MlDsaSignature(
    val parameter: String?,
    val algorithmName: String?,
    val variant: Variant?,
    val hashFunction: HashFunction?,
    val version: Version?,
    key: Key?,
    underlyingNode: Node?,
) : Signature(schemeName = "ML-DSA", key = key, underlyingNode = underlyingNode)

class StatefulHashBasedSignature(
    val parameter: String?,
    schemeName: String?,
    val variant: Variant?,
    val hashFunction: HashFunction?,
    val version: Version?,
    key: Key?,
    underlyingNode: Node?,
) : Signature(schemeName = schemeName, key = key, underlyingNode = underlyingNode)

open class FormattingScheme(val schemeName: String?, underlyingNode: Node?) :
    Concept(underlyingNode = underlyingNode)

class EMSA_PSS(underlyingNode: Node?) : FormattingScheme("EMSA-PSS", underlyingNode)

class DS2(underlyingNode: Node?) : FormattingScheme("DS2", underlyingNode)

class DS3(underlyingNode: Node?) : FormattingScheme("DS3", underlyingNode)

enum class Variant {
    Hedged,
    Deterministic,
}

enum class Version {
    Pure,
    PreHash,
}

class InstallUpdate(val update: AutomaticUpdates, underlyingNode: Node?) :
    Operation(concept = update, underlyingNode = underlyingNode)

/**
 * Represents a safeguard applied to data to ensure data minimisation principles are followed. This
 * concept wraps various protection techniques like encryption, anonymization, pseudonymization, or
 * caching with limited retention.
 */
class DataSafeGuard(val data: Node?, underlyingNode: Node?) : Concept(underlyingNode)

/**
 * Extended [DatabaseStorage] with TTL (Time-To-Live) / retention policy information.
 */
class DatabaseStorageWithTTL(
    val ttlSeconds: Long?,
    val hasAutomatedCleanup: Boolean,
    activityLogging: ActivityLogging?,
    atRestEncryption: Boolean?,
    backups: MutableList<Backup?>,
    immutability: Immutability?,
    resourceLogging: ResourceLogging?,
    internetAccessibleEndpoint: Boolean?,
    geoLocation: GeoLocation?,
    loggings: MutableList<Logging?>,
    redundancies: Redundancy?,
    usageStatistics: UsageStatistics?,
    creation_time: java.time.ZonedDateTime?,
    description: String?,
    labels: MutableMap<String, String>?,
    name: String?,
    raw: String?,
    parent: Resource?,
    underlyingNode: Node?,
) :
    DatabaseStorage(
        activityLogging,
        atRestEncryption,
        backups,
        immutability,
        resourceLogging,
        internetAccessibleEndpoint,
        geoLocation,
        loggings,
        redundancies,
        usageStatistics,
        creation_time,
        description,
        labels,
        name,
        raw,
        parent,
        underlyingNode,
    )
