/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.catalogs.german

import de.fraunhofer.aisec.confirmate.queries.CommunicationProtocol
import de.fraunhofer.aisec.confirmate.queries.HybridCipher
import de.fraunhofer.aisec.confirmate.queries.SymmetricCipher
import de.fraunhofer.aisec.confirmate.queries.TLS1_2
import de.fraunhofer.aisec.confirmate.queries.TLS1_3
import de.fraunhofer.aisec.confirmate.queries.catalogs.CryptoCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.RequirementsCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.TLSCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.checkTLS12Configuration
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.cipherName
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isAES
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isHashFunctionOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isKeyExchangeOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isModus
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isProtocol
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isRSA
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isRandomIv
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isSymmetricCipherOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isUniqueIv
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.ivSizeEqualsBlockSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.keyIsBlockSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.keySizeBiggerThan
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedCertSignatureAlgorithms
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedCipherSuites
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedPSKHandshakeModes
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedSignatureAlgorithms
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedSupportedGroups
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.validAuthTagSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.validIvSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.validKeyLength
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Cipher
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.and
import de.fraunhofer.aisec.cpg.query.mergeWithAll
import de.fraunhofer.aisec.cpg.query.mergeWithAny
import de.fraunhofer.aisec.cpg.query.or

/**
 * Checks the following BSI TRs:
 * - [BSI TR 02102-1 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile&v=13)
 *   regarding cryptographic requirements
 * - [BSI TR 02102-2 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102-2.pdf?__blob=publicationFile&v=11)
 *   regarding TLS
 */
class BSI_TR02102 : RequirementsCatalog(), CryptoCatalog, TLSCatalog {
    context(cipher: SymmetricCipher)
    override fun checkSymmetricEncryption(): QueryTree<Boolean> {
        return cipher.checkAES()
    }

    context(cipher: Cipher)
    override fun checkAsymmetricEncryption(): QueryTree<Boolean> {
        return listOf(cipher.checkRSA(), cipher.checkDLIES(), cipher.checkECIES()).mergeWithAny()
    }

    context(cipher: Cipher)
    override fun checkKeyExchange(): QueryTree<Boolean> {
        TODO()
    }

    context(cipher: Cipher)
    override fun checkHashFunction(): QueryTree<Boolean> {
        TODO()
    }

    context(cipher: CommunicationProtocol)
    override fun checkTLS(): QueryTree<Boolean> {
        return cipher.checkTLS1_2() or cipher.checkTLS1_3()
    }

    override fun checkPQCEncryption(): QueryTree<Boolean> {
        TODO("Not yet implemented")
    }

    // Symmetric encryption algorithms, their modus, and recommended key lengths. There are also
    // requirements on the IV, and interdependencies between accepted key lengths and modus.

    internal fun SymmetricCipher.checkAES(): QueryTree<Boolean> {
        return listOf(checkAesCCM(), checkAesGCM(), checkAesGcmSiv(), checkAesCBC(), checkAesCTR())
            .mergeWithAny(this)
    }

    internal fun SymmetricCipher.checkAesCCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        // Note: The TR itself has no limitation on the key size for AES-CCM, but it references NIST
        // SP
        // 800-38C, which only defines AES-CCM for key sizes of 128 bits.
        val validKeyLengthCheck = this.validKeyLength(listOf(128))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        // TODO: Not sure why the AI suggests me this value. The TR doesn't state anything.
        val ivLengthCheck = this.validIvSize(104)
        val ivIsUniqueCheck = this.isUniqueIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandom = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGcmSiv(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM-SIV")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandomCheck = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM-SIV ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCBC(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CBC")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsRandomCheck = this.isRandomIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CBC ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCTR(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CTR")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsUniqueCheck = this.isUniqueIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CTR ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    // Checking asymmetric crypto

    internal fun Cipher.checkRSA(): QueryTree<Boolean> =
        this.isRSA() and this.keySizeBiggerThan(3000)

    internal fun Cipher.checkDLIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isDLIES =
            QueryTree(
                value = this.cipherName == "DLIES",
                stringRepresentation =
                    if (cipherName == "DLIES") "The algorithm is DLIES"
                    else "The algorithm is not DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(3000)

        return listOf(isDLIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }

    private fun Cipher.checkECIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isECIES =
            QueryTree(
                value = this.cipherName == "ECIES",
                stringRepresentation =
                    if (cipherName == "ECIES") "The algorithm is ECIES"
                    else "The algorithm is not ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(250)

        return listOf(isECIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }

    /**
     * Checks whether the protocol is TLS 1.2 with recommended ciphers and settings. [requiresPFS]
     * is set to `true` if perfect forward secrecy is required by the use-case. [forbidsPSK] should
     * be set to `true` if the use-case does not allow for a pre-shared key. Setting these
     * parameters correctly is important as they influence which ciphers are considered secure.
     */
    private fun CommunicationProtocol.checkTLS1_2(
        requiresPFS: Boolean = false,
        forbidsPSK: Boolean = false,
    ): QueryTree<Boolean> {
        val isTLS12 = isProtocol("TLS", "1.2")
        if (!isTLS12.value) {
            return isTLS12
        } else if (this !is TLS1_2) {
            return QueryTree(
                value = false,
                stringRepresentation = "The protocol is not TLS 1.2",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val goodCiphersWithPFS =
            setOf(
                "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
                "TLS_ECDHE_ECDSA_WITH_AES_256_CCM",
                "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
                "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_DSS_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
                "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_RSA_WITH_AES_128_CCM",
                "TLS_DHE_RSA_WITH_AES_256_CCM",
            )
        val goodCiphersWithoutPFS =
            setOf(
                "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
                "TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
                "TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
                "TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
                "TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
                "TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
            )
        val goodCiphersPsk =
            setOf(
                "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256",
                "TLS_DHE_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_DHE_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_PSK_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_PSK_WITH_AES_128_CCM",
                "TLS_DHE_PSK_WITH_AES_256_CCM",
                "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
            )

        val supportedGroups =
            setOf(
                "secp256r1",
                "secp384r1",
                "secp521r1",
                "brainpoolP256r1",
                "brainpoolP384r1",
                "brainpoolP512r1",
                "ffdhe3072",
                "ffdhe4096",
            )
        val allAllowedSuites = goodCiphersWithPFS.toMutableSet()

        if (!requiresPFS) allAllowedSuites.addAll(goodCiphersWithoutPFS)
        if (!forbidsPSK) allAllowedSuites.addAll(goodCiphersPsk)

        val acceptedSuites = checkTLS12Configuration(allAllowedSuites, supportedGroups)

        // There are several other recommendations e.g. about extensions like
        // encrypt-then-mac, heartbeat, extended master secret. However, these aren't present in the
        // model yet, so we do not check them for now.

        return isTLS12 and acceptedSuites
    }

    /**
     * Checks whether the protocol is TLS 1.3 with recommended ciphers and settings. [forbidsPSK]
     * should be set to `true` if the use-case does not allow for a pre-shared key.
     */
    private fun CommunicationProtocol.checkTLS1_3(forbidsPSK: Boolean = false): QueryTree<Boolean> {
        val isTLS13 = isProtocol("TLS", "1.3")
        if (this !is TLS1_3) {
            return QueryTree(
                value = false,
                stringRepresentation = "The protocol is not TLS 1.3",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        } else if (!isTLS13.value) {
            return isTLS13
        }

        val usesOnlyRecommendedPSKHandshakeModes =
            usesOnlyRecommendedPSKHandshakeModes(
                setOf(
                    "psk_ke", // Until 2026
                    "psk_dhe_ke",
                )
            )

        val usesOnlyRecommendedSupportedGroups =
            this.usesOnlyRecommendedSupportedGroups(
                setOf(
                    "secp256r1",
                    "secp384r1",
                    "secp521r1",
                    "brainpoolP256r1tls13",
                    "brainpoolP384r1tls13",
                    "brainpoolP512r1tls13",
                    "ffdhe3072",
                    "ffdhe4096",
                )
            )

        val usesOnlyRecommendedSignatureAlgorithms =
            usesOnlyRecommendedSignatureAlgorithms(
                setOf(
                    "rsa_pss_rsae_sha256",
                    "rsa_pss_rsae_sha384",
                    "rsa_pss_rsae_sha512",
                    "rsa_pss_pss_sha256",
                    "rsa_pss_pss_sha384",
                    "rsa_pss_pss_sha512",
                    "ecdsa_secp256r1_sha256",
                    "ecdsa_secp384r1_sha384",
                    "ecdsa_secp521r1_sha512",
                    "ecdsa_brainpoolP256r1tls13_sha256",
                    "ecdsa_brainpoolP384r1tls13_sha384",
                    "ecdsa_brainpoolP512r1tls13_sha512",
                )
            )

        val usesOnlyRecommendedCertSignatureAlgorithms =
            this.usesOnlyRecommendedCertSignatureAlgorithms(
                setOf(
                    "rsa_pkcs1_sha256", // Until 2025
                    "rsa_pkcs1_sha384", // Until 2025
                    "rsa_pkcs1_sha512", // Until 2025
                    "rsa_pss_rsae_sha256",
                    "rsa_pss_rsae_sha384",
                    "rsa_pss_rsae_sha512",
                    "rsa_pss_pss_sha256",
                    "rsa_pss_pss_sha384",
                    "rsa_pss_pss_sha512",
                    "ecdsa_secp256r1_sha256",
                    "ecdsa_secp384r1_sha384",
                    "ecdsa_secp521r1_sha512",
                    "ecdsa_brainpoolP256r1tls13_sha256",
                    "ecdsa_brainpoolP384r1tls13_sha384",
                    "ecdsa_brainpoolP512r1tls13_sha512",
                )
            )

        val usesOnlyRecommendedCipherSuites =
            usesOnlyRecommendedCipherSuites(
                setOf("TLS_AES_128_GCM_SHA256", "TLS_AES_256_GCM_SHA384", "TLS_AES_128_CCM_SHA256")
            )

        return isTLS13 and
            listOfNotNull(
                    usesOnlyRecommendedPSKHandshakeModes,
                    usesOnlyRecommendedSupportedGroups,
                    usesOnlyRecommendedSignatureAlgorithms,
                    usesOnlyRecommendedCipherSuites,
                    usesOnlyRecommendedCertSignatureAlgorithms,
                )
                .mergeWithAll()
    }
}
