/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.catalogs.german

import de.fraunhofer.aisec.confirmate.queries.CMAC
import de.fraunhofer.aisec.confirmate.queries.DHKeyExchange
import de.fraunhofer.aisec.confirmate.queries.ECDHKeyExchange
import de.fraunhofer.aisec.confirmate.queries.GMAC
import de.fraunhofer.aisec.confirmate.queries.HMAC
import de.fraunhofer.aisec.confirmate.queries.HashFunction
import de.fraunhofer.aisec.confirmate.queries.HybridCipher
import de.fraunhofer.aisec.confirmate.queries.KMAC
import de.fraunhofer.aisec.confirmate.queries.SHA3_256
import de.fraunhofer.aisec.confirmate.queries.SHA3_384
import de.fraunhofer.aisec.confirmate.queries.SHA3_512
import de.fraunhofer.aisec.confirmate.queries.SHA_256
import de.fraunhofer.aisec.confirmate.queries.SHA_384
import de.fraunhofer.aisec.confirmate.queries.SHA_512
import de.fraunhofer.aisec.confirmate.queries.SHA_512_256
import de.fraunhofer.aisec.confirmate.queries.SymmetricCipher
import de.fraunhofer.aisec.confirmate.queries.TLS1_2
import de.fraunhofer.aisec.confirmate.queries.TLS1_3
import de.fraunhofer.aisec.confirmate.queries.catalogs.CryptoCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.RequirementsCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.TLSCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.checkTLS12Configuration
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.cipherName
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isAES
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isHashFunctionOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isKeyExchangeOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isModus
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isProtocol
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isRSA
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isRandomIv
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isSymmetricCipherOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.isUniqueIv
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.ivSizeEqualsBlockSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.keyIsBlockSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.keySizeBiggerThan
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedCertSignatureAlgorithms
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedCipherSuites
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedPSKHandshakeModes
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedSignatureAlgorithms
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.usesOnlyRecommendedSupportedGroups
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.validAuthTagSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.validIvSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.helpers.validKeyLength
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Cipher
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.MessageAuthenticationCode
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.TransportEncryption
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.and
import de.fraunhofer.aisec.cpg.query.eq
import de.fraunhofer.aisec.cpg.query.mergeWithAll
import de.fraunhofer.aisec.cpg.query.mergeWithAny
import de.fraunhofer.aisec.cpg.query.or

/**
 * Checks the following BSI TRs:
 * - [BSI TR 02102-1 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile&v=13)
 *   regarding cryptographic requirements
 * - [BSI TR 02102-2 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102-2.pdf?__blob=publicationFile&v=11)
 *   regarding TLS
 */
class BSI_TR02102(override val requirePQC: Boolean = false) :
    RequirementsCatalog(), CryptoCatalog, TLSCatalog {

    context(mac: MessageAuthenticationCode)
    override fun checkMAC(): QueryTree<Boolean> {
        // CMAC and GMAC require secure block cipher
        if (mac is CMAC) {
            return QueryTree(
                value = true,
                stringRepresentation = "CMACs are ok.",
                node = mac,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                ((mac.cipher as? SymmetricCipher)?.let { with(it) { checkSymmetricEncryption() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find symmetric cipher for CMAC",
                        node = mac,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        } else if (mac is GMAC) {
            return QueryTree(
                value = true,
                stringRepresentation = "GMACs are ok.",
                node = mac,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                ((mac.cipher as? SymmetricCipher)?.let { with(it) { checkSymmetricEncryption() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find symmetric cipher for GMAC",
                        node = mac,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        } else if (mac is HMAC) {
            // HMAC requires secure hash function
            return QueryTree(
                value = true,
                stringRepresentation = "HMACs are ok.",
                node = mac,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                (mac.hashFunction?.let { with(it) { checkHashFunction() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find hash function for HMAC",
                        node = mac,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        } else if (mac is KMAC) {
            return QueryTree(
                value = true,
                stringRepresentation = "KMACs are ok.",
                node = mac,
                operator = GenericQueryOperators.EVALUATE,
            ) and
                ((mac.strength eq 128) or (mac.strength eq 256)) and
                (mac.hashFunction?.let { with(it) { checkHashFunction() } }
                    ?: QueryTree(
                        false,
                        stringRepresentation = "Could not find hash function for KMAC",
                        node = mac,
                        operator = GenericQueryOperators.EVALUATE,
                    ))
        }

        return QueryTree(
            value = false,
            stringRepresentation = "No valid/secure MAC scheme found",
            node = mac,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    context(cipher: Cipher)
    fun checkKeyEncapsulation(): QueryTree<Boolean> {
        return listOf(
                "FrodoKEM-976",
                "FrodoKEM-1344",
                "mceliece460896",
                "mceliece6688128",
                "mceliece8192128",
                "mceliece460896f",
                "mceliece6688128f",
                "mceliece8192128f",
                "ML-KEM-768",
                "ML-KEM-1024",
            )
            .map { accepted -> accepted eq cipher.cipherName }
            .mergeWithAny()
            .apply {
                this.stringRepresentation =
                    if (this.value) "This is a KEM which is considered as post-quantum secure."
                    else "This is not a KEM which is considered as post-quantum secure."
            }
    }

    context(cipher: SymmetricCipher)
    override fun checkSymmetricEncryption(): QueryTree<Boolean> {
        return cipher.checkAES()
    }

    context(cipher: Cipher)
    override fun checkAsymmetricEncryption(): QueryTree<Boolean> {
        if (requirePQC) return emptyList<QueryTree<Boolean>>().mergeWithAny()

        return listOf(cipher.checkRSA(), cipher.checkDLIES(), cipher.checkECIES()).mergeWithAny()
    }

    context(cipher: Cipher)
    override fun checkKeyExchange(): QueryTree<Boolean> {
        if (requirePQC) return checkKeyEncapsulation()

        return cipher.checkDhKeyExchange() or
            cipher.checkEcdhKeyExchange() or
            checkKeyEncapsulation()
    }

    fun Cipher.checkDhKeyExchange(): QueryTree<Boolean> {
        val isDh = this is DHKeyExchange
        val isDhQt =
            QueryTree<Boolean>(
                value = isDh,
                stringRepresentation =
                    if (isDh) {
                        "The key is exchanged with Diffie-Hellman. That's ok."
                    } else {
                        "They key is not exchanged with Diffie-Hellman."
                    },
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        if (isDh) {
            val keySizeOk = this.keySize?.let { it > 3000 } ?: false
            return isDhQt and
                QueryTree<Boolean>(
                    value = keySizeOk,
                    stringRepresentation =
                        if (keySizeOk) {
                            "The key size is $keySize which is big enough."
                        } else
                            "The key size is $keySize which is not big enough. Minimum requirement is 3000 bit.",
                    node = this,
                    operator = GenericQueryOperators.EVALUATE,
                )
        } else return isDhQt
    }

    fun Cipher.checkEcdhKeyExchange(): QueryTree<Boolean> {
        val acceptedEcParameters =
            listOf("brainpoolP256r1", "brainpoolP320r1", "brainpoolP348r1", "brainpoolP512r1")
        val isEcdh = this is ECDHKeyExchange

        val isEcdhQt =
            QueryTree<Boolean>(
                value = isEcdh,
                stringRepresentation =
                    if (isEcdh) {
                        "The key is exchanged with ECDH. That's ok."
                    } else {
                        "They key is not exchanged with ECDH."
                    },
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        if (!isEcdh) {
            return isEcdhQt
        }
        return isEcdhQt and
            acceptedEcParameters.map { parameter -> parameter eq this.parameter }.mergeWithAny()
    }

    context(hashFunction: HashFunction)
    override fun checkHashFunction(): QueryTree<Boolean> {
        val secureFunctions =
            listOf(
                SHA_256::class,
                SHA_384::class,
                SHA_512::class,
                SHA_512_256::class,
                SHA3_256::class,
                SHA3_384::class,
                SHA3_512::class,
            )
        val isValid = secureFunctions.any { it.isInstance(hashFunction) }
        return QueryTree(
            value = isValid,
            stringRepresentation =
                if (isValid)
                    "The hash function ${hashFunction.hashFunctionName} is considered secure."
                else
                    "The hash function ${hashFunction.hashFunctionName} is not considered secure. Should be one of ${secureFunctions.map { cls -> cls.simpleName }}.",
            node = hashFunction,
            operator = GenericQueryOperators.EVALUATE,
        )
    }

    context(cipher: TransportEncryption)
    override fun checkTLS(): QueryTree<Boolean> {
        return cipher.checkTLS1_2() or cipher.checkTLS1_3()
    }

    // Symmetric encryption algorithms, their modus, and recommended key lengths. There are also
    // requirements on the IV, and interdependencies between accepted key lengths and modus.

    internal fun SymmetricCipher.checkAES(): QueryTree<Boolean> {
        return listOf(checkAesCCM(), checkAesGCM(), checkAesGcmSiv(), checkAesCBC(), checkAesCTR())
            .mergeWithAny(this)
    }

    internal fun SymmetricCipher.checkAesCCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        // Note: The TR itself has no limitation on the key size for AES-CCM, but it references NIST
        // SP
        // 800-38C, which only defines AES-CCM for key sizes of 128 bits.
        val validKeyLengthCheck = this.validKeyLength(listOf(128))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        // TODO: Not sure why the AI suggests me this value. The TR doesn't state anything.
        val ivLengthCheck = this.validIvSize(104)
        val ivIsUniqueCheck = this.isUniqueIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandom = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGcmSiv(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM-SIV")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandomCheck = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM-SIV ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCBC(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CBC")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsRandomCheck = this.isRandomIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CBC ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCTR(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CTR")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsUniqueCheck = this.isUniqueIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CTR ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    // Checking asymmetric crypto

    internal fun Cipher.checkRSA(): QueryTree<Boolean> =
        this.isRSA() and this.keySizeBiggerThan(3000)

    internal fun Cipher.checkDLIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isDLIES =
            QueryTree(
                value = this.cipherName == "DLIES",
                stringRepresentation =
                    if (cipherName == "DLIES") "The algorithm is DLIES"
                    else "The algorithm is not DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(3000)

        return listOf(isDLIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }

    private fun Cipher.checkECIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isECIES =
            QueryTree(
                value = this.cipherName == "ECIES",
                stringRepresentation =
                    if (cipherName == "ECIES") "The algorithm is ECIES"
                    else "The algorithm is not ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(250)

        return listOf(isECIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }

    /**
     * Checks whether the protocol is TLS 1.2 with recommended ciphers and settings. [requiresPFS]
     * is set to `true` if perfect forward secrecy is required by the use-case. [forbidsPSK] should
     * be set to `true` if the use-case does not allow for a pre-shared key. Setting these
     * parameters correctly is important as they influence which ciphers are considered secure.
     */
    private fun TransportEncryption.checkTLS1_2(
        requiresPFS: Boolean = false,
        forbidsPSK: Boolean = false,
    ): QueryTree<Boolean> {
        val isTLS12 = isProtocol("TLS", 1.2f)
        if (!isTLS12.value) {
            return isTLS12
        } else if (this !is TLS1_2) {
            return QueryTree(
                value = false,
                stringRepresentation = "The protocol is not TLS 1.2",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val goodCiphersWithPFS =
            setOf(
                "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
                "TLS_ECDHE_ECDSA_WITH_AES_256_CCM",
                "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
                "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_DSS_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
                "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_RSA_WITH_AES_128_CCM",
                "TLS_DHE_RSA_WITH_AES_256_CCM",
            )
        val goodCiphersWithoutPFS =
            setOf(
                "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                "TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384",
                "TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
                "TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
                "TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
                "TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
                "TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
                "TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
                "TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
                "TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
            )
        val goodCiphersPsk =
            setOf(
                "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384",
                "TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256",
                "TLS_DHE_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_DHE_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_DHE_PSK_WITH_AES_256_GCM_SHA384",
                "TLS_DHE_PSK_WITH_AES_128_CCM",
                "TLS_DHE_PSK_WITH_AES_256_CCM",
                "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
                "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
                "TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
                "TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
            )

        val supportedGroups =
            setOf(
                "secp256r1",
                "secp384r1",
                "secp521r1",
                "brainpoolP256r1",
                "brainpoolP384r1",
                "brainpoolP512r1",
                "ffdhe3072",
                "ffdhe4096",
            )
        val allAllowedSuites = goodCiphersWithPFS.toMutableSet()

        if (!requiresPFS) allAllowedSuites.addAll(goodCiphersWithoutPFS)
        if (!forbidsPSK) allAllowedSuites.addAll(goodCiphersPsk)

        val acceptedSuites = checkTLS12Configuration(allAllowedSuites, supportedGroups)

        // There are several other recommendations e.g. about extensions like
        // encrypt-then-mac, heartbeat, extended master secret. However, these aren't present in the
        // model yet, so we do not check them for now.

        return isTLS12 and acceptedSuites
    }

    /**
     * Checks whether the protocol is TLS 1.3 with recommended ciphers and settings. [forbidsPSK]
     * should be set to `true` if the use-case does not allow for a pre-shared key.
     */
    private fun TransportEncryption.checkTLS1_3(forbidsPSK: Boolean = false): QueryTree<Boolean> {
        val isTLS13 = isProtocol("TLS", 1.3f)
        if (this !is TLS1_3) {
            return QueryTree(
                value = false,
                stringRepresentation = "The protocol is not TLS 1.3",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        } else if (!isTLS13.value) {
            return isTLS13
        }

        val usesOnlyRecommendedPSKHandshakeModes =
            usesOnlyRecommendedPSKHandshakeModes(
                setOf(
                    "psk_ke", // Until 2026
                    "psk_dhe_ke",
                )
            )

        val usesOnlyRecommendedSupportedGroups =
            this.usesOnlyRecommendedSupportedGroups(
                setOf(
                    "secp256r1",
                    "secp384r1",
                    "secp521r1",
                    "brainpoolP256r1tls13",
                    "brainpoolP384r1tls13",
                    "brainpoolP512r1tls13",
                    "ffdhe3072",
                    "ffdhe4096",
                )
            )

        val usesOnlyRecommendedSignatureAlgorithms =
            usesOnlyRecommendedSignatureAlgorithms(
                setOf(
                    "rsa_pss_rsae_sha256",
                    "rsa_pss_rsae_sha384",
                    "rsa_pss_rsae_sha512",
                    "rsa_pss_pss_sha256",
                    "rsa_pss_pss_sha384",
                    "rsa_pss_pss_sha512",
                    "ecdsa_secp256r1_sha256",
                    "ecdsa_secp384r1_sha384",
                    "ecdsa_secp521r1_sha512",
                    "ecdsa_brainpoolP256r1tls13_sha256",
                    "ecdsa_brainpoolP384r1tls13_sha384",
                    "ecdsa_brainpoolP512r1tls13_sha512",
                )
            )

        val usesOnlyRecommendedCertSignatureAlgorithms =
            this.usesOnlyRecommendedCertSignatureAlgorithms(
                setOf(
                    "rsa_pkcs1_sha256", // Until 2025
                    "rsa_pkcs1_sha384", // Until 2025
                    "rsa_pkcs1_sha512", // Until 2025
                    "rsa_pss_rsae_sha256",
                    "rsa_pss_rsae_sha384",
                    "rsa_pss_rsae_sha512",
                    "rsa_pss_pss_sha256",
                    "rsa_pss_pss_sha384",
                    "rsa_pss_pss_sha512",
                    "ecdsa_secp256r1_sha256",
                    "ecdsa_secp384r1_sha384",
                    "ecdsa_secp521r1_sha512",
                    "ecdsa_brainpoolP256r1tls13_sha256",
                    "ecdsa_brainpoolP384r1tls13_sha384",
                    "ecdsa_brainpoolP512r1tls13_sha512",
                )
            )

        val usesOnlyRecommendedCipherSuites =
            usesOnlyRecommendedCipherSuites(
                setOf("TLS_AES_128_GCM_SHA256", "TLS_AES_256_GCM_SHA384", "TLS_AES_128_CCM_SHA256")
            )

        return isTLS13 and
            listOfNotNull(
                    usesOnlyRecommendedPSKHandshakeModes,
                    usesOnlyRecommendedSupportedGroups,
                    usesOnlyRecommendedSignatureAlgorithms,
                    usesOnlyRecommendedCipherSuites,
                    usesOnlyRecommendedCertSignatureAlgorithms,
                )
                .mergeWithAll()
    }
}
