/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.catalogs.german

import de.fraunhofer.aisec.confirmate.queries.CommunicationProtocol
import de.fraunhofer.aisec.confirmate.queries.HybridCipher
import de.fraunhofer.aisec.confirmate.queries.SymmetricCipher
import de.fraunhofer.aisec.confirmate.queries.catalogs.CryptoCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.RequirementsCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.TLSCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.cipherName
import de.fraunhofer.aisec.confirmate.queries.catalogs.isAES
import de.fraunhofer.aisec.confirmate.queries.catalogs.isHashFunctionOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.isKeyExchangeOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.isModus
import de.fraunhofer.aisec.confirmate.queries.catalogs.isRSA
import de.fraunhofer.aisec.confirmate.queries.catalogs.isRandomIv
import de.fraunhofer.aisec.confirmate.queries.catalogs.isSymmetricCipherOk
import de.fraunhofer.aisec.confirmate.queries.catalogs.isUniqueIv
import de.fraunhofer.aisec.confirmate.queries.catalogs.ivSizeEqualsBlockSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.keyIsBlockSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.keySizeBiggerThan
import de.fraunhofer.aisec.confirmate.queries.catalogs.validAuthTagSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.validIvSize
import de.fraunhofer.aisec.confirmate.queries.catalogs.validKeyLength
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Cipher
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.and
import de.fraunhofer.aisec.cpg.query.mergeWithAll
import de.fraunhofer.aisec.cpg.query.mergeWithAny
import de.fraunhofer.aisec.cpg.query.or

/**
 * Checks the following BSI TRs:
 * - [BSI TR 02102-1 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102.pdf?__blob=publicationFile&v=13)
 *   regarding cryptographic requirements
 * - [BSI TR 02102-2 version
 *   2025-01](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR02102/BSI-TR-02102-2.pdf?__blob=publicationFile&v=11)
 *   regarding TLS
 */
class BSI_TR02102 : RequirementsCatalog(), CryptoCatalog, TLSCatalog {
    context(cipher: SymmetricCipher)
    override fun checkSymmetricEncryption(): QueryTree<Boolean> {
        return cipher.checkAES()
    }

    context(cipher: Cipher)
    override fun checkAsymmetricEncryption(): QueryTree<Boolean> {
        return listOf(cipher.checkRSA(), cipher.checkDLIES(), cipher.checkECIES()).mergeWithAny()
    }

    context(cipher: Cipher)
    override fun checkKeyExchange(): QueryTree<Boolean> {
        TODO()
    }

    context(cipher: Cipher)
    override fun checkHashFunction(): QueryTree<Boolean> {
        TODO()
    }

    context(cipher: CommunicationProtocol)
    override fun checkTLS(): QueryTree<Boolean> {
        return cipher.checkTLS1_2() or cipher.checkTLS1_3()
    }

    override fun checkPQCEncryption(): QueryTree<Boolean> {
        TODO("Not yet implemented")
    }

    // Symmetric encryption algorithms, their modus, and recommended key lengths. There are also
    // requirements on the IV, and interdependencies between accepted key lengths and modus.

    internal fun SymmetricCipher.checkAES(): QueryTree<Boolean> {
        return listOf(checkAesCCM(), checkAesGCM(), checkAesGcmSiv(), checkAesCBC(), checkAesCTR())
            .mergeWithAny(this)
    }

    internal fun SymmetricCipher.checkAesCCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        // Note: The TR itself has no limitation on the key size for AES-CCM, but it references NIST
        // SP
        // 800-38C, which only defines AES-CCM for key sizes of 128 bits.
        val validKeyLengthCheck = this.validKeyLength(listOf(128))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        // TODO: Not sure why the AI suggests me this value. The TR doesn't state anything.
        val ivLengthCheck = this.validIvSize(104)
        val ivIsUniqueCheck = this.isUniqueIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGCM(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandom = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesGcmSiv(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("GCM-SIV")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 256))
        // Tag size must be at least 96 bits
        val tagSizeCheck = this.validAuthTagSize(96)
        val ivLengthCheck = this.validIvSize(96)
        val ivIsUniqueCheck = this.isUniqueIv()
        val ivIsRandomCheck = this.isRandomIv()

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                tagSizeCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-GCM-SIV ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCBC(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CBC")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsRandomCheck = this.isRandomIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsRandomCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CBC ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    internal fun SymmetricCipher.checkAesCTR(): QueryTree<Boolean> {
        val algoCheck = this.isAES()
        val modusCheck = this.isModus("CTR")
        val keyIsBlockSizeCheck = this.keyIsBlockSize()
        val validKeyLengthCheck = this.validKeyLength(listOf(128, 192, 256))
        val ivLengthCheck = this.ivSizeEqualsBlockSize()
        val ivIsUniqueCheck = this.isUniqueIv()

        // TODO: There are requirements concerning padding!

        val allChecks =
            listOf(
                algoCheck,
                modusCheck,
                keyIsBlockSizeCheck,
                validKeyLengthCheck,
                ivLengthCheck,
                ivIsUniqueCheck,
            )
        val allChecksPassed = allChecks.all { it.value }

        return QueryTree(
            value = allChecksPassed,
            children = allChecks,
            stringRepresentation =
                "Checks for AES-CTR ${if(allChecksPassed) "passed" else "failed" }.",
            node = this,
            operator = GenericQueryOperators.ALL,
        )
    }

    // Checking asymmetric crypto

    internal fun Cipher.checkRSA(): QueryTree<Boolean> =
        this.isRSA() and this.keySizeBiggerThan(3000)

    internal fun Cipher.checkDLIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isDLIES =
            QueryTree(
                value = this.cipherName == "DLIES",
                stringRepresentation =
                    if (cipherName == "DLIES") "The algorithm is DLIES"
                    else "The algorithm is not DLIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(3000)

        return listOf(isDLIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }

    private fun Cipher.checkECIES(): QueryTree<Boolean> {
        if (this !is HybridCipher) {
            return QueryTree(
                value = false,
                stringRepresentation =
                    "The algorithm is not a hybrid cipher, so it cannot be ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )
        }

        val isECIES =
            QueryTree(
                value = this.cipherName == "ECIES",
                stringRepresentation =
                    if (cipherName == "ECIES") "The algorithm is ECIES"
                    else "The algorithm is not ECIES",
                node = this,
                operator = GenericQueryOperators.EVALUATE,
            )

        val symmetricCipherOk = this.isSymmetricCipherOk()

        val hashFunctionOk = this.isHashFunctionOk()

        // One of the two things is redundant
        val keyexchangeOk = this.isKeyExchangeOk()
        val keysizeOk = this.keySizeBiggerThan(250)

        return listOf(isECIES, keysizeOk, symmetricCipherOk, hashFunctionOk, keyexchangeOk)
            .mergeWithAll()
    }
}
