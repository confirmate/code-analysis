/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.queries.GetCurrentTime
import de.fraunhofer.aisec.confirmate.queries.LogWriteWithArguments
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.assumptions.AssumptionType
import de.fraunhofer.aisec.cpg.assumptions.assume
import de.fraunhofer.aisec.cpg.graph.Backward
import de.fraunhofer.aisec.cpg.graph.BranchingNode
import de.fraunhofer.aisec.cpg.graph.GraphToFollow
import de.fraunhofer.aisec.cpg.graph.Interprocedural
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Identity
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.LogWrite
import de.fraunhofer.aisec.cpg.graph.edges.flows.ControlDependence
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.Must
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.dataFlow
import de.fraunhofer.aisec.cpg.query.executionPath
import de.fraunhofer.aisec.cpg.query.or

context(translationResult: TranslationResult)
fun loggingEnabledByDefault(): QueryTree<Boolean> {
    return QueryTree(
            value = true,
            stringRepresentation = "Logging enabled by default",
            operator = GenericQueryOperators.EVALUATE,
        )
        .assume(
            AssumptionType.ConceptAssumption,
            """We assume that logging is enabled by default, i.e., if the user does not explicitly disable logging, it is active.
        
        To validate this assumption, we need to check the initial configuration of the logger and see that disabling logging only affects the user triggering the action."""
                .trimIndent(),
        )
}

context(translationResult: TranslationResult)
fun loggedDataAvailableToUser(): QueryTree<Boolean> {
    TODO()
}

/**
 * This query checks that there is an opt-out mechanism for logging. I.e., it must be possible to
 * disable logging via a specific user input. How this input is provided for the TOE is specified by
 * [inputConfiguringOptOut].
 */
context(translationResult: TranslationResult)
fun loggingOptOut(inputConfiguringOptOut: ((Node) -> Boolean)): QueryTree<Boolean> {
    // Idea: There exists a user input which flows into a CDG parent (possibly transitive) for each
    // logging statement. Probably, the usage of this opt-out input should be logged regardless of
    // its value.
    return translationResult.allExtended<LogWriteWithArguments> { logWrite ->
        // We have to make use of the underlying node here, as the LogWrite itself is not connected
        // via the CDG
        val surroundingCDGNodeIsOptOut =
            logWrite.underlyingNode?.prevCDGEdges?.map { it.isOptOutCheck(inputConfiguringOptOut) }
                ?: emptyList()
        QueryTree(
                value = surroundingCDGNodeIsOptOut.any { it.value },
                children = surroundingCDGNodeIsOptOut,
                stringRepresentation = "Opt-out check for log write",
                node = logWrite,
                operator = GenericQueryOperators.EVALUATE,
            )
            .assume(
                AssumptionType.ControlFlowAssumption,
                """
                We assume that the opt-out check for logging occurs in the closest surrounding branching node.
                
                To validate this assumption, we need if there is a check further away which disables the logging or if the logging is disabled in anther way, e.g. by configuring the log level.
                Note that this is only necessary if the query fails."""
                    .trimIndent(),
            )
    }
}

fun ControlDependence.isOptOutCheck(
    inputConfiguringOptOut: ((Node) -> Boolean)
): QueryTree<Boolean> {
    val branchingNode =
        end as? BranchingNode
            ?: return QueryTree(
                value = false,
                stringRepresentation = "CDG parent is not a branching node",
                node = end,
                operator = GenericQueryOperators.EVALUATE,
            )
    val condition =
        branchingNode.branchedBy
            ?: return QueryTree(
                value = false,
                stringRepresentation = "CDG parent has no condition",
                node = end,
                operator = GenericQueryOperators.EVALUATE,
            )
    return dataFlow(
        startNode = condition,
        direction = Backward(GraphToFollow.DFG),
        type = Must,
        scope = Interprocedural(),
        predicate = inputConfiguringOptOut,
    )
}

/**
 * This query checks that before each relevant activity, there is a logging statement. The logging
 * statement must be triggered based on the configuration of the logger (i.e., the log level has to
 * match).
 *
 * Relevant activities must include:
 * - Modifications to settings (REQ_ER 13.1)
 * - Authentication of users (REQ_ER 13.2)
 *
 * Metric: ActivityLoggingEnabled
 */
context(translationResult: TranslationResult)
fun relevantActivityHasLogging(
    relevantActivitiesSpecifier: ((Node) -> Boolean)
): QueryTree<Boolean> {
    return translationResult.allExtended<Node>(relevantActivitiesSpecifier) { relevantActivity ->
        executionPath(
            startNode = relevantActivity,
            direction = Backward(GraphToFollow.EOG),
            type = Must,
            scope = Interprocedural(),
            predicate = { node -> node is LogWriteWithArguments && node.isLevelEnabled },
        )
    }
}

/**
 * This query checks that before each relevant activity, there is a logging statement. The logging
 * statement must be triggered based on the configuration of the logger (i.e., the log level has to
 * match).
 *
 * In addition, it checks that the log message is meaningful for the activity.
 */
context(translationResult: TranslationResult)
fun relevantActivityHasLoggingWithMeaningfulMessage(
    relevantActivitiesSpecifier: ((Node) -> Boolean)
): QueryTree<Boolean> {
    return translationResult.allExtended<Node>(relevantActivitiesSpecifier) { relevantActivity ->
        executionPath(
            startNode = relevantActivity,
            direction = Backward(GraphToFollow.EOG),
            type = Must,
            scope = Interprocedural(),
            predicate = { node ->
                node is LogWriteWithArguments &&
                    node.isLevelEnabled &&
                    messageMatchesActivity(node.logArguments, relevantActivity)
            },
        )
    }
}

/**
 * Checks whether [this] [LogWriteWithArguments] would actually be executed based on the configured
 * log level for the underlying logger. The information has to be set beforehand in the [Log] node
 * related to [this].
 */
val LogWriteWithArguments.isLevelEnabled: Boolean
    get() {
        return this.logLevelE >= this.concept.logLevelThreshold
    }

/**
 * Checks if the message constructed by [arguments] is meaningful for the [relevantActivity]. I.e.,
 * it should reflect which activity was performed.
 */
fun messageMatchesActivity(arguments: List<Node>, relevantActivity: Node): Boolean {
    // TODO: Maybe use an AI agent to decide if the message constructed by the arguments is
    // meaningful for the activity.
    return true
}

/** This query checks that each [LogWrite] contains a timestamp. */
context(translationResult: TranslationResult)
fun logEntriesHaveTimestamp(): QueryTree<Boolean> {
    return translationResult.allExtended<LogWriteWithArguments> { logWrite ->
        // TODO: Add a list of fields to the Log concept which tells us what information is included
        //   by each log entry. Typically, this is something like a timestamp, a logger name
        val timestampField =
            setOf<Node>() // logWrite.concept.logFields.filter{ it is LogTimestamp }
        val argumentHasTimestamp =
            logWrite.logArguments.map {
                dataFlow(
                    startNode = it,
                    direction = Backward(GraphToFollow.DFG),
                    type = Must,
                    scope = Interprocedural(),
                    predicate = { node -> node is GetCurrentTime },
                )
            }
        QueryTree(
            value = timestampField.isNotEmpty(),
            children = listOf(QueryTree(timestampField, operator = GenericQueryOperators.EVALUATE)),
            operator = GenericQueryOperators.EVALUATE,
        ) or
            QueryTree(
                value = argumentHasTimestamp.any { it.value },
                children = argumentHasTimestamp,
                operator = GenericQueryOperators.EVALUATE,
            )
    }
}

/**
 * This query checks that each [LogWrite] an argument which represents the initiator of the action.
 * We are currently supporting [Identity] as initiator.
 */
context(translationResult: TranslationResult)
fun logEntriesContainInitiator(): QueryTree<Boolean> {
    return translationResult.allExtended<LogWriteWithArguments> { logWrite ->
        val argumentContainsInitiator =
            logWrite.logArguments.map {
                dataFlow(
                    startNode = it,
                    direction = Backward(GraphToFollow.DFG),
                    type = Must,
                    scope = Interprocedural(),
                    predicate = { node -> node is Identity },
                )
            }
        QueryTree(
                value = argumentContainsInitiator.any { it.value },
                children = argumentContainsInitiator,
                operator = GenericQueryOperators.EVALUATE,
            )
            .assume(
                AssumptionType.DataFlowAssumption,
                """
                    We assume that the initiator is always logged via the same argument, i.e., the logging routine does not hold the initiator in different arguments on different paths reaching it.
                    
                    To validate this assumption, we need to check if different paths can contain the initiator and if it is enforced that at least one log argument always holds the initiator of the operation.
                    Note that this is only necessary if the query fails."""
                    .trimIndent(),
            )
    }
}
