/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.queries.GetCurrentTime
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.assumptions.AssumptionType
import de.fraunhofer.aisec.cpg.assumptions.assume
import de.fraunhofer.aisec.cpg.graph.Backward
import de.fraunhofer.aisec.cpg.graph.BranchingNode
import de.fraunhofer.aisec.cpg.graph.GraphToFollow
import de.fraunhofer.aisec.cpg.graph.Interprocedural
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Identity
import de.fraunhofer.aisec.cpg.graph.concepts.logging.LogWrite
import de.fraunhofer.aisec.cpg.graph.edges.flows.ControlDependence
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.Must
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.dataFlow
import de.fraunhofer.aisec.cpg.query.executionPath
import de.fraunhofer.aisec.cpg.query.or

context(translationResult: TranslationResult)
fun loggingEnabledByDefault(): QueryTree<Boolean> {
    TODO()
}

/**
 * This query checks that there is an opt-out mechanism for logging. I.e., it must be possible to
 * disable logging via a specific user input. How this input is provided for the TOE is specified by
 * [inputConfiguringOptOut].
 */
context(translationResult: TranslationResult)
fun loggingOptOut(inputConfiguringOptOut: ((Node) -> Boolean)): QueryTree<Boolean> {
    // Idea: There exists a user input which flows into a CDG parent (possibly transitive) for each
    // logging statement. Probably, the usage of this opt-out input should be logged regardless of
    // its value.
    return translationResult.allExtended<LogWrite> { logWrite ->
        // We have to make use of the underlying node here, as the LogWrite itself is not connected
        // via the CDG
        val surroundingCDGNodeIsOptOut =
            logWrite.underlyingNode?.prevCDGEdges?.map { it.isOptOutCheck(inputConfiguringOptOut) }
                ?: emptyList()
        QueryTree(
                value = surroundingCDGNodeIsOptOut.any { it.value },
                children = surroundingCDGNodeIsOptOut,
                stringRepresentation = "Opt-out check for log write",
                node = logWrite,
                operator = GenericQueryOperators.EVALUATE,
            )
            .assume(
                AssumptionType.ControlFlowAssumption,
                """
                We assume that the opt-out check for logging occurs in the closest surrounding branching node.
                
                To validate this assumption, we need if there is a check further away which disables the logging or if the logging is disabled in anther way, e.g. by configuring the log level.
                Note that this is only necessary if the query fails."""
                    .trimIndent(),
            )
    }
}

fun ControlDependence.isOptOutCheck(
    inputConfiguringOptOut: ((Node) -> Boolean)
): QueryTree<Boolean> {
    val branchingNode =
        end as? BranchingNode
            ?: return QueryTree(
                value = false,
                stringRepresentation = "CDG parent is not a branching node",
                node = end,
                operator = GenericQueryOperators.EVALUATE,
            )
    val condition =
        branchingNode.branchedBy
            ?: return QueryTree(
                value = false,
                stringRepresentation = "CDG parent has no condition",
                node = end,
                operator = GenericQueryOperators.EVALUATE,
            )
    return dataFlow(
        startNode = condition,
        direction = Backward(GraphToFollow.DFG),
        type = Must,
        scope = Interprocedural(),
        predicate = inputConfiguringOptOut,
    )
}

/**
 * This query checks that before each relevant activity, there is a logging statement. The logging
 * statement must be triggered based on the configuration of the logger (i.e., the log level has to
 * match).
 *
 * Relevant activities must include:
 * - Modifications to settings (REQ_ER 13.1)
 * - Authentication of users (REQ_ER 13.2)
 */
context(translationResult: TranslationResult)
fun relevantActivityHasLogging(
    relevantActivitiesSpecifier: ((Node) -> Boolean)
): QueryTree<Boolean> {
    return translationResult.allExtended<Node>(relevantActivitiesSpecifier) { relevantActivity ->
        executionPath(
            startNode = relevantActivity,
            direction = Backward(GraphToFollow.EOG),
            type = Must,
            scope = Interprocedural(),
            predicate = { node -> node is LogWrite && node.isLevelEnabled },
        )
    }
}

/**
 * This query checks that before each relevant activity, there is a logging statement. The logging
 * statement must be triggered based on the configuration of the logger (i.e., the log level has to
 * match).
 *
 * In addition, it checks that the log message is meaningful for the activity.
 */
context(translationResult: TranslationResult)
fun relevantActivityHasLoggingWithMeaningfulMessage(
    relevantActivitiesSpecifier: ((Node) -> Boolean)
): QueryTree<Boolean> {
    return translationResult.allExtended<Node>(relevantActivitiesSpecifier) { relevantActivity ->
        executionPath(
            startNode = relevantActivity,
            direction = Backward(GraphToFollow.EOG),
            type = Must,
            scope = Interprocedural(),
            predicate = { node ->
                node is LogWrite &&
                    node.isLevelEnabled &&
                    messageMatchesActivity(node.logArguments, relevantActivity)
            },
        )
    }
}

/**
 * Checks whether [this] [LogWrite] would actually be executed based on the configured log level for
 * the underlying logger. The information has to be set beforehand in the [Log] node related to
 * [this].
 */
val LogWrite.isLevelEnabled: Boolean
    get() {
        // TODO: Implement proper log level threshold checking. We need to know what is configured
        //   for the respective logger.There are several ways to achieve this, e.g., by looking at
        //   the configuration files or by tracking logger initialization in the code. We should
        //   probably add a field to the Concept and add a check like:
        // return this.logLevel >= this.concept.logLevelThreshold
        return true
    }

/**
 * Checks if the message constructed by [arguments] is meaningful for the [relevantActivity]. I.e.,
 * it should reflect which activity was performed.
 */
fun messageMatchesActivity(arguments: List<Node>, relevantActivity: Node): Boolean {
    // TODO: Maybe use an AI agent to decide if the message constructed by the arguments is
    // meaningful for the activity.
    return true
}

/** This query checks that each [LogWrite] contains a timestamp. */
context(translationResult: TranslationResult)
fun logEntriesHaveTimestamp(): QueryTree<Boolean> {
    return translationResult.allExtended<LogWrite> { logWrite ->
        // TODO: Add a list of fields to the Log concept which tells us what information is included
        //   by each log entry. Typically, this is something like a timestamp, a logger name
        val timestampField =
            setOf<Node>() // logWrite.concept.logFields.filter{ it is LogTimestamp }
        val argumentHasTimestamp =
            logWrite.logArguments.map {
                dataFlow(
                    startNode = it,
                    direction = Backward(GraphToFollow.DFG),
                    type = Must,
                    scope = Interprocedural(),
                    predicate = { node -> node is GetCurrentTime },
                )
            }
        QueryTree(
            value = timestampField.isNotEmpty(),
            children = listOf(QueryTree(timestampField, operator = GenericQueryOperators.EVALUATE)),
            operator = GenericQueryOperators.EVALUATE,
        ) or
            QueryTree(
                value = argumentHasTimestamp.any { it.value },
                children = argumentHasTimestamp,
                operator = GenericQueryOperators.EVALUATE,
            )
    }
}

// TODO: Check the content type that was changed in the output.

/**
 * This query checks that each [LogWrite] an argument which represents the initiator of the action.
 * We are currently supporting [Identity] as initiator.
 */
context(translationResult: TranslationResult)
fun logEntriesContainInitiator(): QueryTree<Boolean> {
    return translationResult.allExtended<LogWrite> { logWrite ->
        val argumentContainsInitiator =
            logWrite.logArguments.map {
                dataFlow(
                    startNode = it,
                    direction = Backward(GraphToFollow.DFG),
                    type = Must,
                    scope = Interprocedural(),
                    predicate = { node -> node is Identity },
                )
            }
        QueryTree(
                value = argumentContainsInitiator.any { it.value },
                children = argumentContainsInitiator,
                operator = GenericQueryOperators.EVALUATE,
            )
            .assume(
                AssumptionType.DataFlowAssumption,
                """
                    We assume that the initiator is always logged via the same argument, i.e., the logging routine does not hold the initiator in different arguments on different paths reaching it.
                    
                    To validate this assumption, we need to check if different paths can contain the initiator and if it is enforced that at least one log argument always holds the initiator of the operation.
                    Note that this is only necessary if the query fails."""
                    .trimIndent(),
            )
    }
}
