/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.integration.AssessesMetrics
import de.fraunhofer.aisec.confirmate.integration.RepresentsEvidences
import de.fraunhofer.aisec.confirmate.queries.DatabaseQueryWithInput
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.graph.Backward
import de.fraunhofer.aisec.cpg.graph.Forward
import de.fraunhofer.aisec.cpg.graph.GraphToFollow
import de.fraunhofer.aisec.cpg.graph.Interprocedural
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.allChildrenWithOverlays
import de.fraunhofer.aisec.cpg.graph.collectAllNextDFGPaths
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseQuery
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseService
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseStorage
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.File
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Identity
import de.fraunhofer.aisec.cpg.graph.concepts.file.DeleteFile
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.May
import de.fraunhofer.aisec.cpg.query.Must
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.dataFlow
import de.fraunhofer.aisec.cpg.query.executionPath
import de.fraunhofer.aisec.cpg.query.mergeWithAll

@AssessesMetrics("SecureDataDeletionMechanismActivated")
@RepresentsEvidences("E102")
context(translationResult: TranslationResult)
fun allowDeletionOfData(
    trigger: (Node) -> Boolean,
    getIdentity: Node.() -> Identity?,
    dataSinks: Collection<Node>,
): QueryTree<Boolean> {
    return translationResult.allExtended<Node>(trigger) { triggerNode ->
        val triggeringUser = triggerNode.getIdentity()
        dataSinks
            .map { sink ->
                when (sink) {
                    is File -> deleteFileOnAllPaths(triggerNode, sink)
                    is DatabaseService ->
                        deleteDatabaseEntriesOnAllPaths(triggerNode, sink, triggeringUser)
                    is DatabaseStorage ->
                        deleteDatabaseEntriesOnAllPaths(triggerNode, sink, triggeringUser)
                    else ->
                        QueryTree(
                            value = false,
                            stringRepresentation =
                                "Data sink type not supported: ${sink::class.java.simpleName}",
                            node = sink,
                            operator = GenericQueryOperators.EVALUATE,
                        )
                }
            }
            .mergeWithAll()
    }
}

fun deleteFileOnAllPaths(startingNode: Node, file: File) =
    executionPath(
        startNode = startingNode,
        direction = Forward(GraphToFollow.EOG),
        type = Must,
        scope = Interprocedural(),
    ) {
        it is DeleteFile && it.file == file
    }

fun deleteDatabaseEntriesOnAllPaths(
    startingNode: Node,
    database: DatabaseService,
    triggeringUser: Identity?,
) =
    executionPath(
        startNode = startingNode,
        direction = Forward(GraphToFollow.EOG),
        type = Must,
        scope = Interprocedural(),
    ) {
        it is DatabaseQuery && it.databaseService == database && it.deletesData(triggeringUser)
    }

fun DatabaseQuery.deletesData(triggeringUser: Identity?): Boolean {
    return this.calls?.any { call -> "delete" in call } == true &&
        (this is DatabaseQueryWithInput &&
            this.parameters.any { param ->
                param == triggeringUser ||
                    dataFlow(
                            startNode = param,
                            type = May,
                            direction = Backward(GraphToFollow.DFG),
                            predicate = { it == triggeringUser },
                        )
                        .value
            } ||
            dataFlow(
                    startNode = this,
                    type = May,
                    direction = Backward(GraphToFollow.DFG),
                    predicate = { it == triggeringUser },
                )
                .value)
}

fun deleteDatabaseEntriesOnAllPaths(
    startingNode: Node,
    database: DatabaseStorage,
    triggeringUser: Identity?,
) =
    executionPath(
        startNode = startingNode,
        direction = Forward(GraphToFollow.EOG),
        type = Must,
        scope = Interprocedural(),
    ) {
        it is DatabaseQuery && it.storage == database && it.deletesData(triggeringUser)
    }

context(translationResult: TranslationResult)
fun sinksHoldingUserData(isSource: (Node) -> Boolean): Set<Node> {
    return translationResult
        .allChildrenWithOverlays<Node>(isSource)
        .flatMap {
            it.collectAllNextDFGPaths(interproceduralAnalysis = true, contextSensitive = true)
                .flatMap { it.nodes }
                .filter { it is DatabaseService || it is File || it is DatabaseStorage }
        }
        .toSet()
}
