/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.integration.AssessesMetrics
import de.fraunhofer.aisec.confirmate.integration.RepresentsEvidences
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.graph.Backward
import de.fraunhofer.aisec.cpg.graph.Forward
import de.fraunhofer.aisec.cpg.graph.GraphToFollow
import de.fraunhofer.aisec.cpg.graph.Interprocedural
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseQuery
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseService
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseStorage
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.File
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Identity
import de.fraunhofer.aisec.cpg.graph.concepts.file.DeleteFile
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.May
import de.fraunhofer.aisec.cpg.query.Must
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.dataFlow
import de.fraunhofer.aisec.cpg.query.executionPath
import de.fraunhofer.aisec.cpg.query.mergeWithAll

@AssessesMetrics("SecureDataDeletionMechanismActivated")
@RepresentsEvidences("E102")
context(translationResult: TranslationResult)
fun allowDeletionOfData(
    trigger: (Node) -> Boolean,
    getIdentity: Node.() -> Identity?,
    dataSinks: List<Node>,
): QueryTree<Boolean> {
    return translationResult.allExtended<Node>(trigger) { triggerNode ->
        val triggeringUser = triggerNode.getIdentity()
        dataSinks
            .map { sink ->
                when (sink) {
                    is File -> deleteFileOnAllPaths(triggerNode, sink)
                    is DatabaseService ->
                        deleteDatabaseEntriesOnAllPaths(triggerNode, sink, triggeringUser)
                    is DatabaseStorage ->
                        deleteDatabaseEntriesOnAllPaths(triggerNode, sink, triggeringUser)
                    else ->
                        QueryTree(
                            value = false,
                            stringRepresentation =
                                "Data sink type not supported: ${sink::class.java.simpleName}",
                            node = sink,
                            operator = GenericQueryOperators.EVALUATE,
                        )
                }
            }
            .mergeWithAll()
    }
}

fun deleteFileOnAllPaths(startingNode: Node, file: File) =
    executionPath(
        startNode = startingNode,
        direction = Forward(GraphToFollow.EOG),
        type = Must,
        scope = Interprocedural(),
    ) {
        it is DeleteFile && it.file == file
    }

fun deleteDatabaseEntriesOnAllPaths(
    startingNode: Node,
    database: DatabaseService,
    triggeringUser: Identity?,
) =
    executionPath(
        startNode = startingNode,
        direction = Forward(GraphToFollow.EOG),
        type = Must,
        scope = Interprocedural(),
    ) {
        it is DatabaseQuery && it.databaseService == database && it.deletesData(triggeringUser)
    }

fun DatabaseQuery.deletesData(triggeringUser: Identity?): Boolean {
    // TODO: How do I figure out what is happening in this query?
    return this.calls.any { call -> "delete" in call } &&
        dataFlow(
                startNode = this,
                type = May,
                direction = Backward(GraphToFollow.DFG),
                predicate = { it == triggeringUser },
            )
            .value
}

fun deleteDatabaseEntriesOnAllPaths(
    startingNode: Node,
    database: DatabaseStorage,
    triggeringUser: Identity?,
) =
    executionPath(
        startNode = startingNode,
        direction = Forward(GraphToFollow.EOG),
        type = Must,
        scope = Interprocedural(),
    ) {
        it is DatabaseQuery && it.storage == database && it.deletesData(triggeringUser)
    }
