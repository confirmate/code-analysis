/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.integration.AssessesMetrics
import de.fraunhofer.aisec.confirmate.integration.RepresentsEvidences
import de.fraunhofer.aisec.confirmate.queries.DataSafeGuard
import de.fraunhofer.aisec.confirmate.queries.DatabaseStorageWithTTL
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.graph.*
import de.fraunhofer.aisec.cpg.graph.concepts.Operation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseStorage
import de.fraunhofer.aisec.cpg.graph.concepts.file.WriteFile
import de.fraunhofer.aisec.cpg.query.*

/**
 * This query checks whether data has appropriate safeguards applied before being stored or
 * transmitted. A safeguard can be encryption, anonymization, pseudonymization, or any other data
 * protection technique represented by a [DataSafeGuard] concept.
 */
@AssessesMetrics("DataMinimisationTechniquesEnabled")
@RepresentsEvidences("E79")
context(tr: TranslationResult)
fun sensitiveDataHasSafeguards(
    isSensitiveData: (Node) -> Boolean,
    // It can be a DatabaseOperation or WriteFile or any other operation
    isStorageOperation: (Node) -> Boolean,
): QueryTree<Boolean> {
    return tr.allExtended<Node>(isStorageOperation) { storageNode ->
        dataFlow(
            startNode = storageNode,
            direction = Backward(GraphToFollow.DFG),
            scope = Interprocedural(),
            predicate = { node ->
                if (isSensitiveData(node)) {
                    hasSafeguardApplied(node)
                } else {
                    // Not sensitive data, continue searching
                    false
                }
            },
        )
    }
}

/**
 * This query checks whether collected data is actually used for computation/processing, or if it's
 * only stored without being processed.
 */
@AssessesMetrics("DataMinimisationTechniquesEnabled")
@RepresentsEvidences("E79")
context(tr: TranslationResult)
fun collectedDataIsProcessed(isDataCollection: (Node) -> Boolean): QueryTree<Boolean> {
    return tr.allExtended<Node>(isDataCollection) { collectionNode ->
        val hasComputation =
            dataFlow(
                startNode = collectionNode,
                direction = Forward(GraphToFollow.DFG),
                scope = Interprocedural(),
                predicate = { node -> node.hasComputationalOperation() },
            )

        hasComputation
    }
}

/** Helper function to determine the node is a computational operation */
fun Node.hasComputationalOperation(): Boolean {
    val hasOperation = this.overlays.any { it is Operation }

    if (hasOperation) {
        // If it has an operation, check if it's NOT a storage operation
        val isStorageOperation =
            this.overlays.any { overlay -> overlay is WriteFile || overlay is DatabaseOperation }

        // We want operations that are NOT storage-only
        return !isStorageOperation
    }

    return false
}

/** Check if a data node has a [DataSafeGuard] applied. */
context(tr: TranslationResult)
fun hasSafeguardApplied(dataNode: Node): Boolean {
    return tr.allExtended<DataSafeGuard> { safeguard ->
        QueryTree(
            value = safeguard.data == dataNode,
            node = safeguard,
            operator = GenericQueryOperators.EVALUATE,
        )
    }
        .value
}

/**
 * This query checks whether database storage has TTL (Time-To-Live) / retention policies
 * configured.
 */
@AssessesMetrics("AutomatedDeletionOfDataEnabled")
@RepresentsEvidences("E80")
context(tr: TranslationResult)
fun dbHasTTLConfigured(): QueryTree<Boolean> {
    return tr.allExtended<DatabaseStorageWithTTL> { dbStorage ->
        QueryTree(
            value = dbStorage.hasTTLOrRetentionPeriod(),
            node = dbStorage,
            operator = GenericQueryOperators.EVALUATE,
        )
    }
}

/** Helper function to check if a [DatabaseStorageWithTTL] has a retention policy configured. */
fun DatabaseStorageWithTTL.hasTTLOrRetentionPeriod(): Boolean {
    if (this.ttlSeconds != null || this.hasAutomatedCleanup) {
        return true
    }

    // Check if backup has a retention period configured
    val hasBackupRetention = this.backups.any { backup -> backup?.retentionPeriod != null }

    // Check if activity logging has a retention period
    val hasActivityLoggingRetention = this.activityLogging?.retentionPeriod != null

    return hasBackupRetention || hasActivityLoggingRetention
}

/**
 * This query checks whether data stored in the database is actually read and used.
 *
 * For each `write` [DatabaseOperation], checks if the written data flows to a read operation.
 */
@AssessesMetrics("DataMinimisationTechniquesEnabled")
@RepresentsEvidences("E80")
context(tr: TranslationResult)
fun dbStoredDataIsRead(
    isWriteOperation: (DatabaseOperation) -> Boolean,
    isReadOperation: (DatabaseOperation) -> Boolean,
): QueryTree<Boolean> {
    return tr.allChildrenWithOverlays<DatabaseOperation> { op -> isWriteOperation(op) }
        .map { write -> write.flowsToReadOperation(isReadOperation) }
        .mergeWithAll()
}

/**
 * Checks if data from a write operation flows to a read operation.
 */
fun DatabaseOperation.flowsToReadOperation(
    isReadOperation: (DatabaseOperation) -> Boolean,
): QueryTree<Boolean> {
    val startNode = this.underlyingNode ?: return QueryTree(
        value = false,
        node = this,
        operator = GenericQueryOperators.EVALUATE,
    )

    // TODO: This only checks forward data flow from write to read operation. Consider checking both directions.
    return dataFlow(
        startNode = startNode,
        direction = Forward(GraphToFollow.DFG),
        scope = Interprocedural(),
        predicate = { node ->
            node.overlays.filterIsInstance<DatabaseOperation>().any(isReadOperation)
        },
    )
}