/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.integration.AssessesMetrics
import de.fraunhofer.aisec.confirmate.integration.RepresentsEvidences
import de.fraunhofer.aisec.confirmate.queries.DataSafeGuard
import de.fraunhofer.aisec.confirmate.queries.DatabaseStorageWithTTL
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.graph.*
import de.fraunhofer.aisec.cpg.graph.concepts.Operation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.DatabaseOperation
import de.fraunhofer.aisec.cpg.graph.concepts.file.WriteFile
import de.fraunhofer.aisec.cpg.graph.concepts.manualExtensions.DatabaseQueryWithInput
import de.fraunhofer.aisec.cpg.query.*

/**
 * This query checks whether data has appropriate safeguards applied before being stored or
 * transmitted. A safeguard can be encryption, anonymization, pseudonymization, or any other data
 * protection technique represented by a [DataSafeGuard] concept.
 */
@AssessesMetrics("DataMinimisationTechniquesEnabled")
@RepresentsEvidences("E79")
context(tr: TranslationResult)
fun sensitiveDataHasSafeguards(
    isSensitiveData: (Node) -> Boolean,
    // It can be a DatabaseOperation or WriteFile or any other operation
    isStorageOperation: (Node) -> Boolean,
): QueryTree<Boolean> {
    return tr.allExtended<Node>(isStorageOperation) { storageNode ->
        dataFlow(
            startNode = storageNode,
            direction = Backward(GraphToFollow.DFG),
            scope = Interprocedural(),
            predicate = { node ->
                if (isSensitiveData(node)) {
                    hasSafeguardApplied(node)
                } else {
                    // Not sensitive data, continue searching
                    false
                }
            },
        )
    }
}

/**
 * This query checks whether collected data is actually used for computation/processing, or if it's
 * only stored without being processed.
 */
@AssessesMetrics("DataMinimisationTechniquesEnabled")
@RepresentsEvidences("E79")
context(tr: TranslationResult)
fun collectedDataIsProcessed(isDataCollection: (Node) -> Boolean): QueryTree<Boolean> {
    return tr.allExtended<Node>(isDataCollection) { collectionNode ->
        val hasComputation =
            dataFlow(
                startNode = collectionNode,
                direction = Forward(GraphToFollow.DFG),
                scope = Interprocedural(),
                predicate = { node -> node.hasComputationalOperation() },
            )

        hasComputation
    }
}

/** Helper function to determine the node is a computational operation */
fun Node.hasComputationalOperation(): Boolean {
    val hasOperation = this.overlays.any { it is Operation }

    if (hasOperation) {
        // If it has an operation, check if it's NOT a storage operation
        val isStorageOperation =
            this.overlays.any { overlay -> overlay is WriteFile || overlay is DatabaseOperation }

        // We want operations that are NOT storage-only
        return !isStorageOperation
    }

    return false
}

/** Check if a data node has a [DataSafeGuard] applied. */
context(tr: TranslationResult)
fun hasSafeguardApplied(dataNode: Node): Boolean {
    return tr.allExtended<DataSafeGuard> { safeguard ->
            QueryTree(
                value = safeguard.data == dataNode,
                node = safeguard,
                operator = GenericQueryOperators.EVALUATE,
            )
        }
        .value
}

/**
 * This query checks whether database storage has TTL (Time-To-Live) / retention policies
 * configured.
 */
@AssessesMetrics("AutomatedDeletionOfDataEnabled")
@RepresentsEvidences("E80")
context(tr: TranslationResult)
fun dbHasTTLConfigured(): QueryTree<Boolean> {
    return tr.allExtended<DatabaseStorageWithTTL> { dbStorage ->
        QueryTree(
            value = dbStorage.hasTTLOrRetentionPeriod(),
            node = dbStorage,
            operator = GenericQueryOperators.EVALUATE,
        )
    }
}

/** Helper function to check if a [DatabaseStorageWithTTL] has a retention policy configured. */
fun DatabaseStorageWithTTL.hasTTLOrRetentionPeriod(): Boolean {
    if (this.ttlSeconds != null || this.hasAutomatedCleanup) {
        return true
    }

    // Check if backup has a retention period configured
    val hasBackupRetention = this.backups.any { backup -> backup?.retentionPeriod != null }

    // Check if activity logging has a retention period
    val hasActivityLoggingRetention = this.activityLogging?.retentionPeriod != null

    return hasBackupRetention || hasActivityLoggingRetention
}

/**
 * Checks whether data stored in the database is actually read and used.
 *
 * Note: Currently we are following the data flow in one direction (Forward). We may need to
 * consider backward flows as well.
 */
@AssessesMetrics("DataMinimisationTechniquesEnabled")
@RepresentsEvidences("E80")
context(tr: TranslationResult)
fun dbStoredDataIsRead(
    isWriteQuery: (DatabaseQueryWithInput) -> Boolean,
    isReadQuery: (DatabaseQueryWithInput) -> Boolean,
): QueryTree<Boolean> {
    return tr.allChildrenWithOverlays<DatabaseQueryWithInput> { query ->
            isWriteQuery(query) && query.parameters.isNotEmpty()
        }
        .map { writeQuery -> writeQuery.parametersFlowToReadQuery(isReadQuery) }
        .mergeWithAll()
}

fun DatabaseQueryWithInput.parametersFlowToReadQuery(
    isReadQuery: (DatabaseQueryWithInput) -> Boolean
): QueryTree<Boolean> {
    val parameterFlows =
        this.parameters.map { param ->
            dataFlow(
                startNode = param,
                direction = Forward(GraphToFollow.DFG),
                scope = Interprocedural(),
                predicate = { node ->
                    node.overlays.filterIsInstance<DatabaseQueryWithInput>().any(isReadQuery)
                },
            )
        }

    return parameterFlows.mergeWithAll()
}
