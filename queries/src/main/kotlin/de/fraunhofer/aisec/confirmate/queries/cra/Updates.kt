/*
 * This file is part of the Confirmate project.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.assumptions.AssumptionType
import de.fraunhofer.aisec.cpg.assumptions.assume
import de.fraunhofer.aisec.cpg.graph.Node
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.AutomaticUpdates
import de.fraunhofer.aisec.cpg.graph.concepts.manualExtensions.InstallUpdate
import de.fraunhofer.aisec.cpg.graph.followPrevCDGUntilHit
import de.fraunhofer.aisec.cpg.query.*
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.QueryTree
import java.time.Duration

context(translationResult: TranslationResult)
fun updatesEnabled(): QueryTree<Boolean> {
    return translationResult.allExtended<AutomaticUpdates> {
        (it.enabled eq true).apply {
            stringRepresentation =
                if (value) "The automatic update is enabled"
                else "The automatic update is disabled, that's not compliant"
        }
    } and
        translationResult
            .existsExtended<AutomaticUpdates> { it.enabled eq true }
            .apply {
                stringRepresentation =
                    if (value) "There should be at least one automatic update"
                    else "There is no automatic update procedure. That's not compliant."
            }
}

context(translationResult: TranslationResult)
fun updateIntervalSmallEnough(maxUpdateInterval: Duration): QueryTree<Boolean> {
    return translationResult.allExtended<AutomaticUpdates> {
        it.interval?.let { interval ->
            (interval.seconds le maxUpdateInterval.seconds).apply {
                stringRepresentation =
                    if (value) "The update interval is ${interval.seconds} seconds which is ok."
                    else
                        "The update interval is ${interval.seconds} seconds which is larger than the maximal accepted interval of ${maxUpdateInterval.seconds} seconds."
            }
        }
            ?: QueryTree(
                value = false,
                stringRepresentation = "Could not identify the update interval",
                node = it,
                operator = GenericQueryOperators.EVALUATE,
            )
    }
}

context(translationResult: TranslationResult)
fun notificationOfUpdates(notificationChannel: (Node) -> Boolean): QueryTree<Boolean> {
    // There must be an execution path from the update to a notification of the user.
    return translationResult.allExtended<AutomaticUpdates> {
        executionPath(startNode = it, type = Must, predicate = notificationChannel)
    }
}

context(translationResult: TranslationResult)
fun updateCanBePostponed(postponeInput: (Node) -> Boolean): QueryTree<Boolean> {
    // There installation of the update must depend (prev CDG) on the decision of the postpone input
    // (not postponed -> install).
    return translationResult.allExtended<AutomaticUpdates> {
        it.ops
            .filterIsInstance<InstallUpdate>()
            .map { install ->
                val executionDependsOnInput =
                    install.followPrevCDGUntilHit(
                        collectFailedPaths = true,
                        findAllPossiblePaths = true,
                        interproceduralAnalysis = true,
                        predicate = postponeInput,
                    )

                QueryTree(
                        value = executionDependsOnInput.failed.isEmpty(),
                        node = install,
                        children =
                            executionDependsOnInput.fulfilled.map {
                                QueryTree(
                                        value = it,
                                        node = install,
                                        operator = GenericQueryOperators.EVALUATE,
                                    )
                                    .assume(
                                        AssumptionType.ControlFlowAssumption,
                                        "We assume that the correct branch between the input postponing the update and the actual update is taken.\n\nPlease validate this manually.",
                                    )
                            } +
                                executionDependsOnInput.failed.map {
                                    QueryTree(
                                        value = it.second,
                                        node = install,
                                        operator = GenericQueryOperators.EVALUATE,
                                    )
                                },
                        operator = GenericQueryOperators.ALL,
                    )
                    .apply {
                        stringRepresentation =
                            if (value) {
                                "The execution of the update always depends on a specified user input."
                            } else {
                                "The update can be executed and there's a path on which the user cannot postpone it."
                            }
                    }
            }
            .mergeWithAll()
    }
}
