/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.queries.HttpEndpointWithProtocol
import de.fraunhofer.aisec.confirmate.queries.catalogs.CryptoCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.TLSCatalog
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.assumptions.AssumptionType
import de.fraunhofer.aisec.cpg.assumptions.assume
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Configuration
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpRequest
import de.fraunhofer.aisec.cpg.graph.concepts.http.HttpEndpointOperation
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.and
import de.fraunhofer.aisec.cpg.query.eq
import de.fraunhofer.aisec.cpg.query.existsExtended

/**
 * Checks if all relevant HTTP requests use secure transport protocols.
 *
 * @param requiresSecureConnection Function to determine which HTTP requests require a secure
 *   connection
 */
context(
translationResult: TranslationResult,
cryptoCatalog: CryptoCatalog,
protocolCatalog: TLSCatalog)
fun httpRequestsUseSecureTransport(
    requiresSecureConnection: (HttpRequest) -> Boolean
): QueryTree<Boolean> {
    return translationResult.allExtended<HttpRequest>(
        sel = requiresSecureConnection,
        mustSatisfy = { request -> request.linkedConcept.isTLS eq true },
    )
}

context(
translationResult: TranslationResult,
cryptoCatalog: CryptoCatalog,
protocolCatalog: TLSCatalog)
fun secureHttpResponses(
    requiresSecureConnection: (HttpEndpointOperation) -> Boolean
): QueryTree<Boolean> =
    // We start with the HttpEndpointOperations as they represent the server-side handling of
    // requests
    translationResult.allExtended<HttpEndpointOperation>(requiresSecureConnection) {
        // Get the HttpClient and check if it's configured to use (only) TLS.
        val secureChannel =
            (it.concept as? HttpEndpointWithProtocol)?.protocol?.let {
                with(it) { protocolCatalog.checkTLS() }
            }
                ?: QueryTree(
                    value = false,
                    stringRepresentation = "No communication protocol configured for endpoint",
                    node = it,
                    operator = GenericQueryOperators.EVALUATE,
                )

        // We need a secure channel or the data must be used for some other integrity protection
        // before sending
        secureChannel
    }

/**
 * Checks if configuration indicates that encryption is enabled.
 *
 * @param encryptionEnabledCheck Function to determine if encryption is enabled in configuration
 */
context(translationResult: TranslationResult)
fun configurationHasEncryptionEnabled(
    encryptionEnabledCheck: (Configuration) -> Boolean
): QueryTree<Boolean> {
    return translationResult.existsExtended<Configuration>(
        mustSatisfy = { config ->
            val hasTlsConfig = encryptionEnabledCheck(config)

            QueryTree(
                    value = hasTlsConfig,
                    stringRepresentation =
                        if (hasTlsConfig) {
                            "Configuration has TLS/encryption enabled"
                        } else {
                            // TODO(): return QueryTree?
                            "Configuration does not explicitly enable TLS/encryption"
                        },
                    children =
                        mutableListOf(QueryTree(config, operator = GenericQueryOperators.EVALUATE)),
                    operator = GenericQueryOperators.EVALUATE,
                    node = config,
                )
                .assume(
                    AssumptionType.InputAssumptions,
                    "We assume that the function correctly identifies encryption settings. ",
                )
        }
    )
}

/**
 * This query checks requirement X1.1.7: "Products with digital elements shall protect the integrity
 * of stored, transmitted or otherwise processed data, personal or other, commands, programs and
 * configuration against any manipulation or modification not authorised by the user, and report on
 * corruptions."
 *
 * Evidence: E73 - Use of secure transfer protocols Metric: InTransitEncryptionEnabled
 *
 * @param requiresSecureConnection Function to determine which HTTP requests require a secure
 *   connection
 * @param secureConnectionEnabledCheck Function to determine if secure connection is enabled in
 *   configuration
 */
context(
translationResult: TranslationResult,
cryptoCatalog: CryptoCatalog,
protocolCatalog: TLSCatalog)
fun secureProtocolsEnabled(
    requiresSecureConnection: (HttpRequest) -> Boolean,
    secureConnectionEnabledCheck: (Configuration) -> Boolean,
): QueryTree<Boolean> {
    val secureHttpRequests = httpRequestsUseSecureTransport(requiresSecureConnection)
    // Let's just say that all responses need encryption.
    val secureHttpResponses = secureHttpResponses({ true })

    val secureConfig = configurationHasEncryptionEnabled(secureConnectionEnabledCheck)

    return secureHttpRequests and secureHttpResponses and secureConfig
}
