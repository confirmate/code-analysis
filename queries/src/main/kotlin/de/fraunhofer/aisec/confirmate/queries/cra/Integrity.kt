/*
 * This file is part of the Confirmate project.
 */
package de.fraunhofer.aisec.confirmate.queries.cra

import de.fraunhofer.aisec.confirmate.integration.AssessesMetrics
import de.fraunhofer.aisec.confirmate.integration.RepresentsEvidences
import de.fraunhofer.aisec.confirmate.queries.HttpClientWithProtocol
import de.fraunhofer.aisec.confirmate.queries.catalogs.CryptoCatalog
import de.fraunhofer.aisec.confirmate.queries.catalogs.TLSCatalog
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Configuration
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpEndpoint
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpEndpointOperation
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpRequest
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.and
import de.fraunhofer.aisec.cpg.query.eq

/**
 * Checks if all relevant HTTP requests use secure transport protocols.
 *
 * @param requiresSecureConnection Function to determine which HTTP requests require a secure
 *   connection
 */
context(
translationResult: TranslationResult,
cryptoCatalog: CryptoCatalog,
protocolCatalog: TLSCatalog)
fun httpRequestsUseSecureTransport(
    requiresSecureConnection: (HttpRequest) -> Boolean
): QueryTree<Boolean> {
    return translationResult.allExtended<HttpRequest>(
        sel = requiresSecureConnection,
        mustSatisfy = { request ->
            (request.linkedConcept as? HttpClientWithProtocol)?.protocol?.let { protocol ->
                with(protocol) { protocolCatalog.checkTLS() }
            } ?: (request.linkedConcept.isTLS eq true)
        },
    )
}

context(
translationResult: TranslationResult,
cryptoCatalog: CryptoCatalog,
protocolCatalog: TLSCatalog)
fun secureHttpResponses(
    requiresSecureConnection: (HttpEndpointOperation) -> Boolean
): QueryTree<Boolean> =
    // We start with the HttpEndpointOperations as they represent the server-side handling of
    // requests
    translationResult.allExtended<HttpEndpointOperation>(requiresSecureConnection) {
        // Get the HttpClient and check if it's configured to use (only) TLS.
        val secureChannel =
            (it.concept as? HttpEndpoint)?.transportEncryption?.let {
                with(it) { protocolCatalog.checkTLS() }
            }
                ?: QueryTree(
                    value = false,
                    stringRepresentation = "No communication protocol configured for endpoint",
                    node = it,
                    operator = GenericQueryOperators.EVALUATE,
                )

        // We need a secure channel or the data must be used for some other integrity protection
        // before sending
        secureChannel
    }

/**
 * This query checks requirement X1.1.7: "Products with digital elements shall protect the integrity
 * of stored, transmitted or otherwise processed data, personal or other, commands, programs and
 * configuration against any manipulation or modification not authorised by the user, and report on
 * corruptions."
 *
 * Evidence: E73 - Use of secure transfer protocols Metric: InTransitEncryptionEnabled
 *
 * @param requiresSecureConnection Function to determine which HTTP requests require a secure
 *   connection
 * @param secureConnectionEnabledCheck Function to determine if secure connection is enabled in
 *   configuration
 */
@AssessesMetrics("InTransitEncryptionEnabled")
@RepresentsEvidences("E69", "E73", "E101")
context(
translationResult: TranslationResult,
cryptoCatalog: CryptoCatalog,
protocolCatalog: TLSCatalog)
fun secureProtocolsEnabled(
    requiresSecureConnection: (HttpRequest) -> Boolean,
    secureConnectionEnabledCheck: (Configuration) -> Boolean,
): QueryTree<Boolean> {
    val secureHttpRequests = httpRequestsUseSecureTransport(requiresSecureConnection)
    // Let's just say that all responses need encryption.
    val secureHttpResponses = secureHttpResponses({ true })

    return secureHttpRequests and secureHttpResponses
}
