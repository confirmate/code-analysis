package queries.encryption

import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.assumptions.AssumptionType
import de.fraunhofer.aisec.cpg.assumptions.assume
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.HttpRequest
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.ConfigurationOption
import de.fraunhofer.aisec.cpg.graph.concepts.autoGenerated.Configuration
import de.fraunhofer.aisec.cpg.query.QueryTree
import de.fraunhofer.aisec.cpg.query.GenericQueryOperators
import de.fraunhofer.aisec.cpg.query.allExtended
import de.fraunhofer.aisec.cpg.query.existsExtended
import de.fraunhofer.aisec.cpg.query.eq
import de.fraunhofer.aisec.cpg.query.IN
import de.fraunhofer.aisec.cpg.query.or


/**
 * Checks if all relevant HTTP requests use secure transport protocols.
 *
 * @param requiresEncryption Function to determine which HTTP requests require encryption
 */
context(translationResult: TranslationResult)
fun httpRequestsUseSecureTransport(
    requiresEncryption: (HttpRequest) -> Boolean
): QueryTree<Boolean> {
    return translationResult.allExtended<HttpRequest>(
        sel = requiresEncryption,
        mustSatisfy = { request ->
            request.linkedConcept.isTLS eq true
        }
    )
}

/**
 * Checks if configuration indicates that encryption is enabled.
 *
 * @param encryptionEnabledCheck Function to determine if encryption is enabled in configuration
 */
context(translationResult: TranslationResult)
fun configurationHasEncryptionEnabled(
    encryptionEnabledCheck: (Configuration) -> Boolean
): QueryTree<Boolean> {
    return translationResult.existsExtended<Configuration>(
        mustSatisfy = { config ->
            val hasTlsConfig = encryptionEnabledCheck(config)

            QueryTree(
                value = hasTlsConfig,
                stringRepresentation = if (hasTlsConfig) {
                    "Configuration has TLS/encryption enabled"
                } else {
                    // TODO(): return QueryTree?
                    "Configuration does not explicitly enable TLS/encryption"
                },
                children = mutableListOf(
                    QueryTree(config, operator = GenericQueryOperators.EVALUATE)
                ),
                operator = GenericQueryOperators.EVALUATE,
                node = config
            ).assume(
                AssumptionType.InputAssumptions,
                "We assume that the function correctly identifies encryption settings. "
            )
        }
    )
}

/**
 * This query checks requirement X1.1.7: "Products with digital elements shall protect the
 * integrity of stored, transmitted or otherwise processed data, personal or other, commands,
 * programs and configuration against any manipulation or modification not authorised by the user,
 * and report on corruptions."
 *
 * Evidence: E73 - Use of secure transfer protocols
 * Metric: InTransitEncryptionEnabled
 *
 * @param requiresEncryption Function to determine which HTTP requests require encryption
 * @param encryptionEnabledCheck Function to determine if encryption is enabled in configuration
 */
context(translationResult: TranslationResult)
fun inTransitEncryptionEnabled(
    requiresEncryption: (HttpRequest) -> Boolean,
    encryptionEnabledCheck: (Configuration) -> Boolean
): QueryTree<Boolean> {
    val secureHttpRequests = translationResult.httpRequestsUseSecureTransport(requiresEncryption)

    val secureConfig = translationResult.configurationHasEncryptionEnabled(encryptionEnabledCheck)

    return secureHttpRequests and secureConfig
}