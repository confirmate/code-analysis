/*
 * This source file was generated by the Gradle 'init' task
 */
@file:OptIn(ExperimentalUuidApi::class)

package org.example

import com.azure.ai.openai.OpenAIClient
import com.azure.ai.openai.OpenAIClientBuilder
import com.azure.ai.openai.models.ChatCompletionsOptions
import com.azure.ai.openai.models.ChatRequestMessage
import com.azure.ai.openai.models.ChatRequestSystemMessage
import com.azure.ai.openai.models.ChatRequestUserMessage
import com.azure.core.credential.AzureKeyCredential
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.databind.ser.std.StdSerializer
import de.fraunhofer.aisec.cpg.TranslationConfiguration
import de.fraunhofer.aisec.cpg.TranslationManager
import de.fraunhofer.aisec.cpg.TranslationResult
import de.fraunhofer.aisec.cpg.frontends.python.PythonLanguage
import io.clouditor.api.AssessmentApi
import io.clouditor.api.EvidenceStoreApi
import io.clouditor.api.ExperimentalDiscoveryApi
import io.clouditor.api.OrchestratorApi
import io.clouditor.model.Application
import io.clouditor.model.AssessmentResult
import io.clouditor.model.CodeModule
import io.clouditor.model.Evidence
import io.clouditor.model.GoogleProtobufAny
import io.clouditor.model.MetricConfiguration
import io.clouditor.model.Resource
import io.clouditor.model.UpdateResourceRequest
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.plugins.auth.*
import io.ktor.client.plugins.auth.providers.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.request.forms.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.util.logging.Logger
import kotlinx.coroutines.async
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import org.example.passes.CryptoPass
import org.example.passes.ontologyObjects
import org.openapitools.client.infrastructure.ApiClient.Companion.JSON_DEFAULT
import java.nio.file.Path
import java.time.OffsetDateTime
import kotlin.collections.HashMap
import kotlin.collections.firstOrNull
import kotlin.collections.forEach
import kotlin.collections.lastOrNull
import kotlin.collections.listOf
import kotlin.collections.set
import kotlin.io.path.Path
import kotlin.io.path.name
import kotlin.io.path.pathString
import kotlin.io.path.readText
import kotlin.reflect.KClass
import kotlin.reflect.full.memberProperties
import kotlin.time.Duration.Companion.minutes
import kotlin.uuid.ExperimentalUuidApi
import kotlin.uuid.Uuid


var key = System.getenv("AZURE_OPENAI_KEY")
var base = System.getenv("AZURE_OPENAI_BASE")

var aiClient = OpenAIClientBuilder()
    .credential(AzureKeyCredential(key))
    .endpoint(base)
    .buildClient();

var topLevel = Path("targets/pythonpass")
var files =
    listOf(
        "backend/app/routes/auth.py",
        "backend/app/routes/passwords.py",
        "backend/app/services/auth_service.py",
        "backend/app/services/password_service.py",
        "backend/app/utils/auth.py",
        "backend/app/utils/encryption.py",
        "backend/app/models.py",
        "backend/app/extensions.py",
        "backend/config.py",
        "backend/__main__.py",
    ).map { topLevel.resolve(it) }

class App {
    fun analyzeCode(): TranslationResult {
        val config = TranslationConfiguration.builder()
            .topLevel(topLevel.toFile())
            .sourceLocations(topLevel.resolve("backend").toFile())
            .registerLanguage<PythonLanguage>()
            .registerPass<CryptoPass>()
            .defaultPasses()
            .build()

        val analyzer = TranslationManager.builder()
            .config(config)
            .build()

        return analyzer.analyze().get()
    }
}

fun main(args: Array<String>) {
    val analyzer = App()
    val result = analyzer.analyzeCode()

    val resources = result.ontologyObjects

    runBlocking {
        val client = ConfirmateClient(result)
        var t = async {
            client.doAi()
        }
        resources.forEach { client.sendResource(it) }

        if(args.getOrNull(0) == "--daemon") {
            // Send evidence every 2 hour(s)
            while(true) {
                client.syncWithTarget()

                println("Sending regular evidence...")
                resources.forEach { client.sendResource(it) }

                println("Doing AI magic...")
                async {
                    client.doAi()
                }

                delay(120.minutes)
            }
        }
        t.join()
    }
}

@Serializable
data class AIResult(
    var correct: Boolean?,
    var message: String,
)

fun OpenAIClient.askAI(files: List<Path>, question: String): AIResult? {
    var completions = this.getChatCompletions(
        "gpt-4o-mini-2024-07-18",
        ChatCompletionsOptions(
            listOf<ChatRequestMessage>(
                ChatRequestSystemMessage("You are a security analyst looking at source code to find aspects that are interesting with regards to security compliance. You will answer questions and provide the answer in a JSON format. The JSON has two properties, a field 'correct' and a field 'message' contains the answer. No other output is provided except the JSON. Please also specify source code locations (including filename), if appropriate. Please only look at the code, do not speculate on the environment."),
                ChatRequestUserMessage("Please look at the following code: ${files.embed()}. $question")
            )
        )
    )

    // Retrieve raw and strip markdown
    var raw = completions.choices.firstOrNull()?.message?.content
    if(raw == null) {
        return null
    }
    raw = raw.substring("```json".length, raw.length - 3)

    return Json.decodeFromString<AIResult>(raw)
}

fun List<Path>.embed(): String {
    return this.map { it.embed() }.joinToString("\n\n")
}

fun Path.embed(): String {
    return "${this.pathString}\n```${this.readText()}```"
}

private fun Evidence.toResource(): Resource {
    val r = Resource(
        id = this.resource?.get("id") as? String,
        resourceType = this.resource?.resourceType,
        certificationTargetId = certificationTargetId,
        toolId = "code-analyzer",
        properties = this.resource,
    )

    return r
}

val GoogleProtobufAny.resourceType: String?
    get() {
        return this.atType?.split(".")?.lastOrNull()
    }

fun <T : Any> T.toAny(): GoogleProtobufAny {
    var type = "type.googleapis.com/clouditor.ontology.v1.${this::class.simpleName}"
    val any = GoogleProtobufAny(atType = type)
    for(prop in (this::class as KClass<T>).memberProperties) {
        val value = prop.get(this) ?: continue
        any[prop.name] = if (value::class.isData) {
            value.toAny()
        } else {
            value
        }
    }
    any["@type"] = any.atType as String

    return any
}

suspend fun oauthToken(clientID: String, clientSecret: String): String? {
    val client = HttpClient {
        install(ContentNegotiation) {
            json()
        }
    }

        val response = client.submitForm(System.getenv("AUTH_TOKEN_ENDPOINT") ?: "http://localhost:8080/v1/auth/token",
            formParameters = parameters {
                append("grant_type", "client_credentials")
            }) {
            basicAuth(clientID,clientSecret)
        }
    val map = response.body<HashMap<String, String>>()

    return map["access_token"]
}

class ConfirmateClient(var tr: TranslationResult) {
    var certificationTargetId: String? = null

    val assApi: AssessmentApi
    val evApi: EvidenceStoreApi
    val orchApi: OrchestratorApi
    val discApi: ExperimentalDiscoveryApi

    /*private val module = SerializersModule {
        contextual(GoogleProtobufAny::class, GoogleProtobufAnySerializer)
    }*/

    init {
        val token = runBlocking {
            oauthToken(System.getenv("AUTH_CLIENT_ID") ?: "clouditor",
                System.getenv("AUTH_CLIENT_SECRET") ?: "clouditor")
        }

        val config: (HttpClientConfig<*>) -> Unit = {
            it.install(Auth) {
                bearer {
                    loadTokens {
                        BearerTokens(token!!, "")
                    }
                }
            }
            it.install(ContentNegotiation) {
                /*json(json = Json{
                    serializersModule = module
                })*/
            }
        }

        val jsonBlock: ObjectMapper.() -> Unit = {
            JSON_DEFAULT(this)

            val module = SimpleModule()
            //module.addSerializer(GoogleProtobufAny::class.java, AnySerializer())
            registerModule(module)
            disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
        }

        val baseUrl = System.getenv("CONFIRMATE_API_BASE") ?: "http://localhost:8080"

        assApi = AssessmentApi(baseUrl, httpClientConfig = config, jsonBlock = jsonBlock)
        evApi = EvidenceStoreApi(baseUrl, httpClientConfig = config, jsonBlock = jsonBlock)
        orchApi = OrchestratorApi(baseUrl, httpClientConfig = config, jsonBlock = jsonBlock)
        discApi = ExperimentalDiscoveryApi(baseUrl, httpClientConfig = config, jsonBlock = jsonBlock)

        syncWithTarget()
    }

    fun syncWithTarget() {
        // Fetch cert target with "pythonpass"
        val target = runBlocking {
            orchApi.orchestratorListCertificationTargets(pageSize = 1500, pageToken = "", orderBy = "name", asc = false).body().targets.firstOrNull { it.name == "pythonpass" }
        }

        if(target == null) {
            throw RuntimeException("could not find target for pythonpass")
        }

        println("Syncing to certification target ${target.id} now")

        certificationTargetId = target.id
    }

    private fun Any.toEvidence(): Evidence {
        val ev = Evidence(
            id = Uuid.random().toString(),
            resource = this.toAny(),
            timestamp = OffsetDateTime.now(),
            certificationTargetId = certificationTargetId,
            toolId = "code-analyzer",
        )

        return ev
    }

    fun AIResult.toAssessmentResults(metricId: String): List<AssessmentResult> {
        val relevantFiles = files.map { Pair(topLevel.relativize(it), it.name) }.
        filter { this.message.contains(it.second) }
        // Let's try to re-connect this somehow to an existing resource
        val modules = relevantFiles.
        map { it.first.parent.pathString.replace("/", ".") }.
        distinct().
        mapNotNull { pkg -> tr.ontologyObjects.filterIsInstance<CodeModule>().firstOrNull { it.id == pkg  } }

        if(modules.isEmpty()) {
            println("Found no modules. Falling back to application")
            // Fallback to the application
            var app = tr.ontologyObjects.filterIsInstance<Application>().firstOrNull()

            return listOf(AssessmentResult(
                id = Uuid.random().toString(),
                timestamp = OffsetDateTime.now(),
                metricId = metricId,
                metricConfiguration = MetricConfiguration(
                    operator = "==",
                    targetValue = true,
                    metricId = metricId,
                    certificationTargetId = certificationTargetId,
                    isDefault = true
                ),
                compliant = this.correct,
                // fake
                evidenceId = Uuid.random().toString(),
                resourceId = app?.id ?: "TBD",
                resourceTypes = listOf("Application"),
                complianceComment = this.message,
                certificationTargetId = certificationTargetId
            ))
        } else {
            println("Found ${modules.size} for files $relevantFiles")

            return modules.map {
                AssessmentResult(
                    id = Uuid.random().toString(),
                    timestamp = OffsetDateTime.now(),
                    metricId = metricId,
                    metricConfiguration = MetricConfiguration(
                        operator = "==",
                        targetValue = true,
                        metricId = metricId,
                        certificationTargetId = certificationTargetId,
                        isDefault = true
                    ),
                    compliant = this.correct,
                    // fake
                    evidenceId = Uuid.random().toString(),
                    resourceId = it.id,
                    resourceTypes = listOf("CodeModule"),
                    complianceComment = this.message,
                    certificationTargetId = certificationTargetId
                )
            }
        }
    }

    suspend fun sendAssessmentResult(result: AssessmentResult) {
        var out =  orchApi.orchestratorStoreAssessmentResult(result)
            if (!out.success) {
            val map = out.response.body<HashMap<String, Any>>()
            println(map["message"])
        }
    }

    suspend fun sendResource(obj: Any) {
        val ev = obj.toEvidence()
            //val result1 = evApi.evidenceStoreStoreEvidence(ev)
        val result1 = assApi.assessmentAssessEvidence(ev)
        if (!result1.success) {
            val map = result1.response.body<HashMap<String, Any>>()
            println(map["message"])
        }

            val result2 = discApi.experimentalDiscoveryUpdateResource(
                ev.resource?.get("id")!! as String ,
                UpdateResourceRequest(ev.toResource()),
            )
        if (!result2.success) {
            val map = result1.response.body<HashMap<String, Any>>()
            println(map["message"])
        }
    }

    suspend fun doAi() {
        try {
            var questions = mapOf(
                "Does it offer access control?" to "AccessControlMechanismsImplemented",
                "Does it offer transport encryption?" to "TransportEncryptionEnabled",
                "Does it only collect and process data which is necessary to fulfill its intended purpose? The purpose is a password manager system. Focus on data-flows, not on encryption." to "NecessaryDataProcessing",
                "Is the code free of hard-coded passwords?" to "NoHardCodedSecurityData",
                "Does the code functionality work without remote services?" to "CoreFunctionalityWithoutRemote",
            )
            for(question in questions) {
                println("Asking: ${question.key}")
                var aiResult = aiClient.askAI(files, question.key)
                if(aiResult == null) {
                    throw RuntimeException("Could not ask AI")
                }

                println(aiResult)
                aiResult.toAssessmentResults(question.value).forEach {
                    sendAssessmentResult(it)
                }
            }
        } catch(e: Exception) {
            println("AI did bad")
            e.printStackTrace()
        }
    }
}

object GoogleProtobufAnySerializer : KSerializer<GoogleProtobufAny> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("GoogleProtobufAny", PrimitiveKind.LONG)
    override fun serialize(encoder: Encoder, value: GoogleProtobufAny)  {
        // NO idea
    }
    override fun deserialize(decoder: Decoder): GoogleProtobufAny = TODO()
}

class AnySerializer() : StdSerializer<GoogleProtobufAny>(GoogleProtobufAny::class.java) {
    override fun serialize(
        p0: GoogleProtobufAny?,
        p1: JsonGenerator?,
        p2: SerializerProvider?
    ) {
    }

}
